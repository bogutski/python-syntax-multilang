Метод `Array.prototype.sort()` — это мощный инструмент JavaScript для сортировки массивов. 

Он изменяет порядок элементов в массиве на месте и возвращает отсортированный массив. 

Этот метод особенно полезен, когда необходимо упорядочить данные по какому-либо критерию.


### Основы метода `sort()`

Метод `sort()` вызывается на массиве и по умолчанию сортирует его элементы как строки в лексикографическом порядке:

```javascript
const fruits = ['banana', 'apple', 'pear'];
fruits.sort();
console.log(fruits); // Вывод: ['apple', 'banana', 'pear']
```


Это поведение полезно, когда вы работаете со строками. Однако, когда дело доходит до чисел, стандартное поведение может привести к неожиданным результатам:

```javascript
const numbers = [10, 5, 1, 44, 20];
numbers.sort();
console.log(numbers); // Вывод: [1, 10, 20, 44, 5]
```

Числа сортируются как строки, что может быть не тем, что вы ожидаете. Для корректной сортировки чисел необходимо предоставить `sort()` функцию сравнения.


### Функция сравнения

Чтобы управлять процессом сортировки, `sort()` может принимать функцию сравнения, которая определяет порядок элементов. 

Функция сравнения принимает два аргумента (обозначим их `a` и `b`), которые представляют собой сравниваемые элементы массива. Результатом `a - b` будет:

* Отрицательное число, если `a` меньше `b` (что означает, что `a` должен идти перед `b`).
* Положительное число, если `a` больше `b` (что означает, что `a` должен идти после `b`).
* Ноль, если они равны (порядок можно не изменять).


Пример функции для чисел:

```javascript
const numbers1 = [10, 5, 1, 44, 20];
numbers1.sort((a, b) => a - b);
console.log(numbers1); // Вывод: [1, 5, 10, 20, 44]


const numbers2 = [10, 5, 1, 44, 20];
numbers2.sort((a, b) => b - a);
console.log(numbers2); // Вывод: [44, 20, 10, 5, 1]
```


### Продвинутое использование

`sort()` не ограничивается простыми типами данных. Вы можете сортировать объекты, используя критерии, основанные на значениях свойств объектов:

```javascript
const items = [
    { name: 'Apple', price: 50 },
    { name: 'Banana', price: 10 },
    { name: 'Pear', price: 20 }
];
items.sort((a, b) => a.price - b.price);

console.log(items); 
// Вывод: [{ name: 'Banana', price: 10 }, { name: 'Pear', price: 20 }, { name: 'Apple', price: 50 }]
```


### Использование дополнительного метода `localeCompare()`

Метод `localeCompare()` позволяет сравнивать строки с учётом локальных особенностей языка. Это особенно важно для правильной сортировки строк, содержащих диакритические знаки, различные алфавиты и другие лингвистические особенности.


#### Основное использование

`localeCompare()` сравнивает вызывающую строку с переданной строкой и возвращает:

* Отрицательное значение, если вызывающая строка должна идти первее.
* Положительное значение, если вызывающая строка должна идти позже.
* Ноль, если строки считаются равными.


Пример:

```javascript
const words = ['resume', 'résumé', 'exposé', 'déjà vu'];

// Сортировка без учета диакритических знаков
words.sort((a, b) => a.localeCompare(b, 'en', { sensitivity: 'base' }));

console.log(words); // [ 'déjà vu', 'exposé', 'resume', 'résumé' ]
```


#### Параметры `localeCompare()`

* **locales**: Аргумент для указания локали (например, 'en-US').
* **options**: Объект для более детальной настройки сравнения, включая чувствительность к регистру, диакритическим знакам, и пр.


Рассмотрим еще один пример с применением методов: `sort()` и `localeCompare()`.

Отсортируем массив строк по последнему символу каждой строки, учитывая локальные особенности.
```javascript
const words = ['apple', 'banana', 'cherry', 'date'];

words.sort((a, b) => {
    // Получаем последний символ каждой строки
    const lastCharA = a[a.length - 1];
    const lastCharB = b[b.length - 1];

    // Сравниваем последние символы с учетом локальных особенностей
    return lastCharA.localeCompare(lastCharB);
});

console.log(words);
// Вывод может зависеть от локали и дополнительных настроек, например:
// ['banana', 'apple', 'date', 'cherry'] - если сортировать по английской локали без дополнительных настроек
```


### Особенности и предостережения

* **Сортировка на месте:** `sort()` изменяет исходный массив, что означает, что оригинальный массив будет отсортирован после вызова метода.
* **Производительность:** Время выполнения `sort()` может быть значительным для больших массивов, так как его сложность зависит от реализации конкретного движка JavaScript.
* **Устойчивость:** Сортировка не гарантированно устойчива во всех браузерах, хотя большинство современных реализаций обеспечивают устойчивую сортировку.
