{
  "_id": "6696c2cb763f0712c198f5f7",
  "name": {
    "en": "/*",
    "ru": "Сортировка продуктов по весу и цене"
  },
  "instruction": {
    "en": "",
    "ru": "Напишите функцию `sortProductsByWeightAndPrice`, которая принимает массив объектов продуктов.\n\nКаждый объект содержит свойства `name`, `weight`, и `price`.\n\nФункция должна возвращать новый массив, содержащий продукты, отсортированные сначала по весу в порядке возрастания, а при равенстве веса — по цене в порядке убывания.\n\n\nПримеры запуска функции:\n```javascript\nconst products = [\n  { name: \"Product A\", weight: 200, price: 1.99 },\n  { name: \"Product B\", weight: 150, price: 2.99 },\n  { name: \"Product C\", weight: 150, price: 3.99 },\n  { name: \"Product D\", weight: 100, price: 0.99 }\n];\n\nconsole.log(sortProductsByWeightAndPrice(products));\n// Вывод: [\n//   { name: \"Product D\", weight: 100, price: 0.99 },\n//   { name: \"Product C\", weight: 150, price: 3.99 },\n//   { name: \"Product B\", weight: 150, price: 2.99 },\n//   { name: \"Product A\", weight: 200, price: 1.99 }\n// ]\n```"
  },
  "initialSolution": "function sortProductsByWeightAndPrice(){\n\n}",
  "completedSolution": "function sortProductsByWeightAndPrice(arr) {\n  return arr.slice().sort((a, b) => {\n    if(a.weight === b.weight) return b.price - a.price\n    else return a.weight - b.weight\n  });\n}",
  "openTest": "it('Created function sortProductsByWeightAndPrice', () => {\n  expect(sortProductsByWeightAndPrice).to.be.a('function');\n});\n\nit('Function sortProductsByWeightAndPrice should include method sort()', () => {\n  const res = sortProductsByWeightAndPrice.toString()\n  expect(res).to.include('.sort(')\n});\n\nit('sortProductsByWeightAndPrice should sort products first by weight ascending, then by price descending', () => {\n  const products = [\n    { name: \"Product A\", weight: 200, price: 1.99 },\n    { name: \"Product B\", weight: 150, price: 2.99 },\n    { name: \"Product C\", weight: 150, price: 3.99 },\n    { name: \"Product D\", weight: 100, price: 0.99 }\n  ];\n  expect(sortProductsByWeightAndPrice(products)).to.deep.equal([\n    { name: \"Product D\", weight: 100, price: 0.99 },\n    { name: \"Product C\", weight: 150, price: 3.99 },\n    { name: \"Product B\", weight: 150, price: 2.99 },\n    { name: \"Product A\", weight: 200, price: 1.99 }\n  ]);\n});\n\nit('sortProductsByWeightAndPrice with an empty array should return an empty array', () => {\n  expect(sortProductsByWeightAndPrice([])).to.deep.equal([]);\n});\n\nit('sortProductsByWeightAndPrice with one product should return the same single product array', () => {\n  const product = [{ name: \"Single Product\", weight: 120, price: 4.99 }];\n  expect(sortProductsByWeightAndPrice(product)).to.deep.equal(product);\n});\n\nit('sortProductsByWeightAndPrice handles products with the same weight and different prices', () => {\n  const products = [\n    { name: \"Product A\", weight: 150, price: 1.00 },\n    { name: \"Product B\", weight: 150, price: 3.00 }\n  ];\n  expect(sortProductsByWeightAndPrice(products)).to.deep.equal([\n    { name: \"Product B\", weight: 150, price: 3.00 },\n    { name: \"Product A\", weight: 150, price: 1.00 }\n  ]);\n});\n\nit('sortProductsByWeightAndPrice sorts correctly when all products have the same price but different weights', () => {\n  const products = [\n    { name: \"Product A\", weight: 200, price: 2.99 },\n    { name: \"Product B\", weight: 100, price: 2.99 }\n  ];\n  expect(sortProductsByWeightAndPrice(products)).to.deep.equal([\n    { name: \"Product B\", weight: 100, price: 2.99 },\n    { name: \"Product A\", weight: 200, price: 2.99 }\n  ]);\n});\n\nit('sortProductsByWeightAndPrice should sort by price descending when weights are the same', () => {\n  const products = [\n    { name: \"Product A\", weight: 150, price: 2.50 },\n    { name: \"Product B\", weight: 150, price: 3.50 }\n  ];\n  expect(sortProductsByWeightAndPrice(products)).to.deep.equal([\n    { name: \"Product B\", weight: 150, price: 3.50 },\n    { name: \"Product A\", weight: 150, price: 2.50 }\n  ]);\n});\n\nit('sortProductsByWeightAndPrice should sort a mix of different weights and prices correctly', () => {\n  const products = [\n    { name: \"Product A\", weight: 200, price: 1.99 },\n    { name: \"Product B\", weight: 100, price: 0.99 },\n    { name: \"Product C\", weight: 150, price: 2.99 }\n  ];\n  expect(sortProductsByWeightAndPrice(products)).to.deep.equal([\n    { name: \"Product B\", weight: 100, price: 0.99 },\n    { name: \"Product C\", weight: 150, price: 2.99 },\n    { name: \"Product A\", weight: 200, price: 1.99 }\n  ]);\n});\n\nit('sortProductsByWeightAndPrice should handle large arrays efficiently', () => {\n  let largeArray = Array.from({ length: 1000 }, (_, i) => ({ name: `Product ${i}`, weight: i % 50, price: Math.random() * 100 }));\n  largeArray = sortProductsByWeightAndPrice(largeArray);\n  expect(largeArray[0].weight <= largeArray[1].weight).to.be.true;\n});",
  "hiddenTest": "",
  "programmingLang": "JavaScript",
  "status": "new",
  "level": "Easy",
  "showOpenTest": true,
  "active": false,
  "checker": "unit",
  "hint": {
    "en": "",
    "ru": ""
  }
}