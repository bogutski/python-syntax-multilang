{
  "_id": "6696c2ca763f0712c198eb34",
  "name": {
    "en": "Select from the array all the words that contain a given letter",
    "ru": "Выбрать из массива все слова, которые содержат заданную букву"
  },
  "instruction": {
    "en": "The `filterByLetter` function takes 2 arguments:\n\n* an array of `words` consisting of strings\n* the string `letter`, which can consist of a single letter or be empty.\n\nThe function must return a string made up of those array elements that contain the letter `letter`.\nThe words in the string must be separated by semicolons, no semicolon after the last word.\n\nThe search for a letter in a word must be case insensitive - bring the letter and the word to the same case before comparing.\n(The word must be added to the result string in the case in which it was in the array.)\n\nIf the passed string `letter` is empty, then there is no filtering by letter, the function returns all words of the array.\n\nIf the passed array is empty or there are no words with the necessary letter in the array, the function must return an empty string.\n\nExamples of function call:\n\n```javascript\nfilterByLetter(['colors', 'war', 'cast', 'worlds'], 'x'); // ''\nfilterByLetter(['colors', 'War', 'cast', 'worlds'], 'W'); // 'War;worlds'\nfilterByLetter(['colors', 'war', 'cast', 'worlds'], ''); // 'colors;war;cast;worlds' - фильтр выключен\nfilterByLetter([], 'z'); // ''\n```\n\nNote how the `indexOf` method works: if its argument is an empty string, it always returns `0`!",
    "ru": "Функция `filterByLetter` принимает 2 аргумента:\n\n* массив `words`, состоящий из строк\n* строку `letter`, которая может состоять из одной буквы или быть пустой.\n\nФункция должна вернуть строку, составленную из тех элементов массива, в которых содержится буква `letter`.\nСлова в строке должны быть разделены точками с запятой, после последнего слова точка с запятой не ставится.\n\nПоиск буквы в слове должен быть независимым от регистра - приведите букву и слово к одному регистру перед сравнением.\n(Слово должно быть добавлено в строку результата в том регистре, в котором оно было в массиве.)\n\nЕсли переданная строка `letter` пустая, то фильтрация по букве не производится, функция возвращает все слова массива.\n\nЕсли переданный массив пустой или в массиве нет слов с нужной буквой, то функция должна вернуть пустую строку.\n\nПримеры вызова функции:\n\n```javascript\nfilterByLetter(['colors', 'war', 'cast', 'worlds'], 'x'); // ''\nfilterByLetter(['colors', 'War', 'cast', 'worlds'], 'W'); // 'War;worlds'\nfilterByLetter(['colors', 'war', 'cast', 'worlds'], ''); // 'colors;war;cast;worlds' - фильтр выключен\nfilterByLetter([], 'z'); // ''\n```\n\nОбратите внимание на то, как работает метод `indexOf`: в случае, если его аргументом является пустая строка, он всегда возвращает `0`!"
  },
  "initialSolution": "fun",
  "completedSolution": "function filterByLetter(words, letter) {\n  let result = '';\n  letter = letter.toLowerCase();\n  for (let i = 0; i < words.length; i++) {\n    if (letter === '' || words[i].toLowerCase().indexOf(letter) !== -1) {\n      if (result !== '') {// если в строке уже есть хоть одно слово, то добавляем точку с запятой\n        result = result + ';';\n      }\n      result += words[i]; // добавляем оригинальное слово из массива в строку результата\n    }\n  }\n  return result;\n}",
  "openTest": "it('Created function filterByLetter', () => {\n  expect(filterByLetter).to.be.a('function');\n});\n\nit(\"filterByLetter(['West', 'work', 'core', 'rows', 'East'], 'w') should return 'West;work;rows'\", () => {\n  expect(filterByLetter(['West', 'work', 'core', 'rows', 'East'], 'w')).to.equal('West;work;rows');\n});\n\nit(\"filterByLetter(['West', 'work', 'core', 'rows', 'East'], 'E') should return 'West;core;East'\", () => {\n  expect(filterByLetter(['West', 'work', 'core', 'rows', 'East'], 'E')).to.equal('West;core;East');\n});\n\nit(\"filterByLetter(['West', 'work', 'core', 'rows', 'East'], 'e') should return 'West;core;East'\", () => {\n  expect(filterByLetter(['West', 'work', 'core', 'rows', 'East'], 'e')).to.equal('West;core;East');\n});\n\nit(\"filterByLetter(['West', 'work', 'core', 'rows', 'East'], 'C') should return 'core'\", () => {\n  expect(filterByLetter(['West', 'work', 'core', 'rows', 'East'], 'C')).to.equal('core');\n});\n\nit(\"filterByLetter(['West', 'work', 'core', 'rows', 'East'], 'z') should return ''\", () => {\n  expect(filterByLetter(['West', 'work', 'core', 'rows', 'East'], 'z')).to.equal('');\n});\n\nit(\"filterByLetter(['West', 'work', 'core', 'rows', 'East'], '') should return 'West;work;core;rows;East'\", () => {\n  expect(filterByLetter(['West', 'work', 'core', 'rows', 'East'], '')).to.equal('West;work;core;rows;East');\n});\n\nit(\"filterByLetter([], 'W') should return ''\", () => {\n  expect(filterByLetter([], 'W')).to.equal('');\n});\n\nit(\"filterByLetter(['123', 'Tie', 'welcoming', ' ', '', 'I am so sad'], 'w') should return 'welcoming'\", () => {\n  expect(filterByLetter(['123', 'Tie', 'welcoming', ' ', '', 'I am so sad'], 'w')).to.equal('welcoming');\n});\n\nit(\"filterByLetter(['123', 'Tie', 'welcoming', ' ', '', 'I am so sad'], 'I') should return 'Tie;welcoming;I am so sad'\", () => {\n  expect(filterByLetter(['123', 'Tie', 'welcoming', ' ', '', 'I am so sad'], 'I')).to.equal('Tie;welcoming;I am so sad');\n});\n\nit(\"filterByLetter(['123', 'Tie', 'welcoming', ' ', '', 'I am so sad'], ' ') should return ' ;I am so sad'\", () => {\n  expect(filterByLetter(['123', 'Tie', 'welcoming', ' ', '', 'I am so sad'], ' ')).to.equal(' ;I am so sad');\n});\n\nit(\"filterByLetter(['123', 'Tie', 'welcoming', ' ', '', 'I am so sad'], '') should return '123;Tie;welcoming; ;;I am so sad'\", () => {\n  expect(filterByLetter(['123', 'Tie', 'welcoming', ' ', '', 'I am so sad'], '')).to.equal('123;Tie;welcoming; ;;I am so sad');\n});\n\nit(\"filterByLetter(['123', 'Tie', 'welcoming', ' ', '', 'I am so sad'], '1') should return '123'\", () => {\n  expect(filterByLetter(['123', 'Tie', 'welcoming', ' ', '', 'I am so sad'], '1')).to.equal('123');\n});\n\nit(\"filterByLetter(['123', 'Tie', 'welcoming', ' ', '', 'I am so sad'], 'd') should return 'I am so sad'\", () => {\n  expect(filterByLetter(['123', 'Tie', 'welcoming', ' ', '', 'I am so sad'], 'd')).to.equal('I am so sad');\n});\n\nit(\"filterByLetter(['123', 'Tie', 'welcoming', ' ', '', 'I am so sad'], 'e') should return 'Tie;welcoming'\", () => {\n  expect(filterByLetter(['123', 'Tie', 'welcoming', ' ', '', 'I am so sad'], 'e')).to.equal('Tie;welcoming');\n});\n\nit(\"filterByLetter(['123', 'Tie', 'welcoming', ' ', '', 'I am so sad'], 't') should return 'Tie'\", () => {\n  expect(filterByLetter(['123', 'Tie', 'welcoming', ' ', '', 'I am so sad'], 't')).to.equal('Tie');\n});",
  "hiddenTest": "",
  "programmingLang": "JavaScript",
  "status": "new",
  "level": "Easy",
  "showOpenTest": true,
  "active": false,
  "checker": "unit",
  "hint": {
    "en": "",
    "ru": ""
  }
}