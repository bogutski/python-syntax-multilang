{
  "_id": "6696c2ca763f0712c198eb33",
  "name": {
    "en": "Select from the array all the words that have a certain length",
    "ru": "Выбрать из массива все слова, которые имеют определенную длину"
  },
  "instruction": {
    "en": "Fix the bugs in the code and figure out how it works.\n\nThe `filterByLength` function takes 2 arguments:\n\n* an array `words` consisting of strings\n* a non-negative integer `length`.\n\nThe function must return a string made up of those array elements that have a length of `length`.\nThe words in the string must be separated by commas, no comma is needed after the last word.\n\nIf the passed `length` value is 0, no length filtering is performed, the function returns a string containing all words of the array.\n\nIf the passed array is empty, or there are no words of the required length in the array, the function should return an empty string.\n\nExamples of function calls:\n\n```javascript\nfilterByLength(['word', 'words', 'letter', 'letters', 'seven'], 5); // 'words,seven'\nfilterByLength(['Word', 'work', 'cows', 'rows'], 4); // 'Word,work,cows,rows'\nfilterByLength(['Word', 'work', 'cows', 'rows'], 6); // '' - the array does not contain words of the necessary length\nfilterByLength(['color', 'work', 'cow', 'worlds'], 0); // 'color,work,cow,worlds' - filter is off\nfilterByLength([], 4); // ''\n```",
    "ru": "Исправьте ошибки в коде и разберитесь, как он работает.\n\nФункция `filterByLength` принимает 2 аргумента:\n\n* массив `words`, состоящий из строк\n* целое неотрицательное число `length`\n\nФункция должна вернуть строку, составленную из тех элементов массива, которые имеют длину `length`.\nСлова в строке должны быть разделены запятыми, после последнего слова запятая не нужна.\n\nЕсли переданное значение `length` равно 0, то фильтрация по длине не производится, функция возвращает строку, содержащую все слова массива.\n\nЕсли переданный массив пустой или в массиве нет слов нужной длины, то функция должна вернуть пустую строку.\n\nПримеры вызова функции:\n\n```javascript\nfilterByLength(['word', 'words', 'letter', 'letters','seven'], 5); // 'words,seven'\nfilterByLength(['Word', 'work', 'cows', 'rows'], 4); // 'Word,work,cows,rows'\nfilterByLength(['Word', 'work', 'cows', 'rows'], 6); // '' - в массиве нет слов нужной длины\nfilterByLength(['color', 'work', 'cow', 'worlds'], 0); // 'color,work,cow,worlds' - фильтр выключен\nfilterByLength([], 4); // ''\n```"
  },
  "initialSolution": "functions filterByLength(words, length) [\n  const result = '';\n  for (let i = 0; i >= words.length; i+=3) {\n    if (length === 0 || words[k].length === length) {\n      if ( result !== '') {// если в строке уже есть хоть одно слово, то добавляем запятую\n        result = result + ':';\n      }\n      result += word[i] ;\n    }\n  }\n  return letters;\n]",
  "completedSolution": "function filterByLength(words, length) {\n  let result = '';\n  for (let i = 0; i < words.length; i++) {\n    if (length === 0 || words[i].length === length) {\n      if (result !== '') {// если в строке уже есть хоть одно слово, то добавляем запятую\n        result += ',';\n      }\n      result += words[i];\n    }\n  }\n  return result;\n}",
  "openTest": "it('Created function filterByLength', () => {\n  expect(filterByLength).to.be.a('function');\n});\n\nit('filterByLength([\"word\", \"words\", \"letter\", \"letters\", \"seven\"], 5) should return \"words,seven\"', () => {\n  expect(filterByLength(['word', 'words', 'letter', 'letters','seven'], 5)).to.be.equal('words,seven');\n});\n\nit('filterByLength([\"Word\", \"work\", \"cows\", \"rows\"], 4) should return \"Word,work,cows,rows\"', () => {\n  expect(filterByLength(['Word', 'work', 'cows', 'rows'], 4)).to.be.equal('Word,work,cows,rows');\n});\n\nit('filterByLength([\"Word\", \"work\", \"cows\", \"rows\"], 6) should return \"\"', () => {\n  expect(filterByLength(['Word', 'work', 'cows', 'rows'], 6)).to.be.equal('');\n});\n\nit('filterByLength([], 4) should return \"\"', () => {\n  expect(filterByLength([], 4)).to.be.equal('');\n});\n\nit('filterByLength([\"some\", \"flowers\", \"are\", \"very\", \"fragrant\"], 4) should return \"some,very\"', () => {\n  expect(filterByLength(['some', 'flowers', 'are', 'very', 'fragrant'], 4)).to.be.equal('some,very');\n});\n\nit('filterByLength([\"some\", \"cut\", \"are\", \"ram\", \"cat\", \"cone\", \"tan, \"sun\", \"stars\", \"sky\",\"randomize\"], 3) should return \"cut,are,ram,cat,tan,sun,sky\"', () => {\n  expect(filterByLength(['some', 'cut', 'are', 'ram', 'cat', 'cone', 'tan', 'sun', 'stars', 'sky', 'randomize'], 3)).to.be.equal('cut,are,ram,cat,tan,sun,sky');\n});\n\nit('filterByLength([\"cattle\", \"cones\", \"tar, \"sunny\", \"star\", \"skates\",\"randomization\"], 0\") should return \"cattle,cones,tar,sunny,star,skates,randomization\"', () => {\n  expect(filterByLength(['cattle', 'cones', 'tar', 'sunny', 'star', 'skates', 'randomization'], 0)).to.be.equal('cattle,cones,tar,sunny,star,skates,randomization');\n});\n\nit('filterByLength([\"cattle\", \"cones\", \"tar, \"sunny\", \"star\", \"skates\",\"randomization\"], 2) should return \"\"', () => {\n  expect(filterByLength(['cattle', 'cones', 'tar', 'sunny', 'star', 'skates', 'randomization'], 2)).to.be.equal('');\n});\n\nit('filterByLength([\"cattle\", \"cones\", \"tar, \"sunny\", \"star\", \"skates\",\"randomization\"], 6) should return \"cattle,skates\"', () => {\n  expect(filterByLength(['cattle', 'cones', 'tar', 'sunny', 'star', 'skates', 'randomization'], 6)).to.be.equal('cattle,skates');\n});\n\nit('filterByLength([\"I\", \"am\", \"very\", \"very\", \"excited\", \"!\"], 0) should return \"I,am,very,very,excited,!\"', () => {\n  expect(filterByLength(['I', 'am', 'very', 'very', 'excited', '!'], 0)).to.be.equal('I,am,very,very,excited,!');\n});\n\nit('filterByLength([\"I\", \"am\", \"very\", \"very\", \"excited\", \"!\"], 3) should return \"\"', () => {\n  expect(filterByLength(['I', 'am', 'very', 'very', 'excited', '!'], 3)).to.be.equal('');\n});\n\nit('filterByLength([\"I\", \"am\", \"very\", \"very\", \"excited\", \"!\"], 7) should return \"excited\"', () => {\n  expect(filterByLength(['I', 'am', 'very', 'very', 'excited', '!'], 7)).to.be.equal('excited');\n});\n\nit('filterByLength([\"I\", \"am\", \"very\", \"very\", \"excited\", \"!\"], 1) should return \"I,!\"', () => {\n  expect(filterByLength(['I', 'am', 'very', 'very', 'excited', '!'], 1)).to.be.equal('I,!');\n});\n\nit('filterByLength([\"I\", \"am\", \"very\", \"very\", \"excited\", \"!\"], 10) should return \"\"', () => {\n  expect(filterByLength(['I', 'am', 'very', 'very', 'excited', '!'], 10)).to.be.equal('');\n});\n\nit('filterByLength([\"I\", \"am\", \"very\", \"very\", \"excited\", \"!\"], 2) should return \"am\"', () => {\n  expect(filterByLength(['I', 'am', 'very', 'very', 'excited', '!'], 2)).to.be.equal('am');\n});",
  "hiddenTest": "",
  "programmingLang": "JavaScript",
  "status": "new",
  "level": "Easy",
  "showOpenTest": true,
  "active": false,
  "checker": "unit",
  "hint": {
    "en": "",
    "ru": ""
  }
}