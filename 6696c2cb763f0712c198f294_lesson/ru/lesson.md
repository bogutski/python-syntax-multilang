Подсчет количества вхождений каждого элемента в массив — распространенная задача при обработке данных. В JavaScript для решения этой задачи можно использовать несколько подходов.

### Подход с использованием `объекта` и цикла `for`

Использование объекта позволяет легко отслеживать количество вхождений каждого элемента.

Пример:

```javascript
function countOccurrences(arr) {
    const count = {}; // Инициализация пустого объекта для хранения результатов

    // Использование цикла для перебора элементов массива
    for (let i = 0; i < arr.length; i++) {
        const element = arr[i];
        if (count[element]) {    // Проверка, существует ли уже ключ в объекте count
            count[element] += 1; // Увеличение значения на 1, если ключ существует
        } else {
            count[element] = 1;  // Создание ключа с начальным значением 1, если ключ не существует
        }
    }

    return count;
}

console.log(countOccurrences(['apple', 'banana', 'apple', 'orange', 'banana', 'apple']));
// Вывод: { apple: 3, banana: 2, orange: 1 }
```

### Использование метода `reduce`

* Метод `reduce` применяется к массиву и используется для получения единственного результата на основе всех его элементов.
* Функция, передаваемая в `reduce`, вызывается для каждого элемента массива, принимая аккумулирующее значение (аккумулятор) и текущий элемент массива. 
* Результат каждого вызова функции сохраняется в аккумуляторе и передается для обработки следующего элемента.

Сигнатура метода
```javascript
array.reduce(callback(accumulator, currentValue, currentIndex, array), initialValue)
```

* `callback` — функция, выполняемая на каждом шаге;
* `accumulator` — аккумулирующее значение, которое возвращает callback после выполнения на текущем элементе;
* `currentValue` — текущий обрабатываемый элемент массива;
* `currentIndex` (необязательно) — индекс текущего обрабатываемого элемента массива;
* `array` (необязательно) — обрабатываемый массив;
* `initialValue` (необязательно) — начальное значение аккумулятора.

Если `initialValue` не указан, то в качестве начального значения аккумулятора используется первый элемент массива, а итерация начинается со второго элемента.

Пример: Рассмотрим простой пример использования reduce для подсчета суммы элементов массива:

```javascript
const numbers = [1, 2, 3];

const sum = numbers.reduce((accumulator, currentValue) => {
    return accumulator + currentValue;
}, 0); // Начальное значение аккумулятора — 0

console.log(sum); // Вывод: 6
```

Пошаговое объяснение:
1. Инициализация аккумулятора значением 0.
2. Первый вызов функции: аккумулятор 0, currentValue 1, возвращается 1. 
3. Второй вызов: аккумулятор 1, currentValue 2, возвращается 3. 
4. Третий вызов: аккумулятор 3, currentValue 3, возвращается 6. 
5. В конце выполнения метод reduce возвращает конечное значение аккумулятора 6.


Теперь применим метод `reduce` к нашей задаче.

```javascript
function countOccurrencesReduce(arr){
    return arr.reduce((acc, curr) => {
        acc[curr] = (acc[curr] || 0) + 1; // Добавляем или обновляем количество вхождений элемента
        return acc; // Возвращаем аккумулятор для следующей итерации
    }, {}) // Начальное значение аккумулятора — пустой объект
}

console.log(countOccurrencesReduce([1, 2, 1, 3, 2, 2])) // { '1': 2, '2': 3, '3': 1 }
console.log(countOccurrencesReduce(['apple', 'banana', 'apple', 'orange', 'banana', 'apple']))
// { apple: 3, banana: 2, orange: 1 }
```

Различные подходы к подсчету количества вхождений элементов в массив позволяют выбрать оптимальное решение в зависимости от конкретной задачи и предпочтений программиста.