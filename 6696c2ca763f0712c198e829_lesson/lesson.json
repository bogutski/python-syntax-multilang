{
  "_id": "6696c2ca763f0712c198e829",
  "content": {
    "ru": "Копирование массива является важной операцией при работе с массивами. Она может понадобиться в различных ситуациях, например, когда нужно сохранить копию исходного массива для последующей работы с ней, не изменяя оригинальный массив.\n\nРассмотрим пример:\n\n```javascript\nconst f1 = ['Bill', 'Alice', 'Carson', 'KJ', 'Viktor'];\n\nconst f2 = f1;\n\nconsole.log(f2); // ['Bill', 'Alice', 'Carson', 'KJ', 'Viktor']\nconsole.log(f1 === f2); // true\n\nf1[0] = 'Bob'; // изменяем первый элемент в массиве f1\n\nconsole.log(f2); // ['Bob', 'Alice', 'Carson', 'KJ', 'Viktor']\nconsole.log(f1); // ['Bob', 'Alice', 'Carson', 'KJ', 'Viktor']\n```\n\nВ данном пример массив `f2` является ссылкой на массив `f1`, а не его копией. Поэтому при изменении `f2` будут изменен и `f1`, и наоборот.\n\nТакое поведение связано с тем, что в JavaScript примитивные типы данных (например, числа, строки, булевы значения) копируются по значению, а не по ссылке, а массивы и объекты - по ссылке. Это означает, что при присваивании переменной массива или объекта создается не новый объект, а лишь новая ссылка на существующий объект.\n\nСуществует несколько способов копирования массивов, рассмотрим их подробнее.\n\n### Метод `slice()`\n\nМетод `slice()` используется для создания нового массива, содержащего копию части или всего исходного массива.\n\nСинтаксис метода `slice()`:\n\n```javascript\narray.slice(begin, end)\n```\n\nАргументы `begin` и `end` опциональны и указывают начальный и конечный индексы, между которыми нужно скопировать элементы массива. Если не указать аргументы, метод `slice()` скопирует весь массив.\n\nМетод `slice()` не изменяет исходный массив, а возвращает новый массив.\n\n```javascript\nconst f1 = ['Bill', 'Alice', 'Carson', 'KJ', 'Viktor'];\n\nconst f2 = f1.slice();\n\nconsole.log(f2); // ['Bill', 'Alice', 'Carson', 'KJ', 'Viktor']\nconsole.log(f2 === f1); // false\n\nf1[0] = 'Bob'; // изменяем первый элемент в массиве f1\n\nconsole.log(f2); // ['Bill', 'Alice', 'Carson', 'KJ', 'Viktor'], f2 не изменился\nconsole.log(f1); // ['Bob', 'Alice', 'Carson', 'KJ', 'Viktor']\n```\n\nРассмотрим недостатки этого метода :\n\n```javascript\nconst f1 = [{name: 'Alex'}, {name: 'Joe'}];\n\nconst f2 = f1.slice();\n\nconsole.log(f2); // [{name: 'Alex'}, {name: 'Joe'}]\nconsole.log(f2 === f1); // false\n\nf1[0].name = 'Viktor'; // изменяем имя в первом элемент в массиве f1\n\nconsole.log(f2); // [{name: 'Viktor'}, {name: 'Joe'}], f2 изменился\nconsole.log(f1); // [{name: 'Viktor'}, {name: 'Joe'}]\n```\n\nВидим, что массив `f2` также изменился и теперь содержит объект с измененным свойством `name`.\n\nЭто происходит потому, что метод `slice()` копирует только значения элементов массива, а не их ссылки. В данном случае, когда мы копируем массив, мы копируем ссылки на объекты, содержащиеся в массиве. Поэтому, когда мы изменяем свойство объекта в `f1`, это изменение отражается и в `f2`, потому что оба массива содержат ссылку на один и тот же объект.\n\nЧтобы избежать этой проблемы, нужно создавать полную копию объектов, содержащихся в массиве.\n\n`JSON.stringify()` и `JSON.parse()` - это методы, которые используются для преобразования данных в формат `JSON` и обратно.\n\n* `JSON.stringify()` принимает объект или массив и преобразует его в строку JSON.\n* `JSON.parse()` принимает строку JSON и преобразует ее в объект или массив.\n\n```javascript\nconst f1 = [{name: 'Alex'}, {name: 'Joe'}];\n\nconst f1String = JSON.stringify(f1);\n\nconsole.log(f1String); // '[{name: 'Alex'}, {name: 'Joe'}]' - строка\nconsole.log(typeof f1String); // string\nconsole.log(f1String[0]); // '['\nconsole.log(f1); // [{name: 'Viktor'}, {name: 'Joe'}] - массив\n\nconst f2 = JSON.parse(f1String)\nconsole.log(f2); // [{name: 'Viktor'}, {name: 'Joe'}] - массив\nconsole.log(f1); // [{name: 'Viktor'}, {name: 'Joe'}] - массив\n\nconsole.log(f2 === f1); // false\n\n//проверим или теперь при изменении имени в первом элементе f1 будет меняться f2\nf1[0].name = 'Abb'\n\nconsole.log(f2); // [{name: 'Viktor'}, {name: 'Joe'}], не поменялся\nconsole.log(f1); // [{name: 'Abb'}, {name: 'Joe'}], поменялся\n```\n\nТакже для копирования массива можно использовать оператор `spread`.\n\n### Оператор Spread `...`\n\nОператор spread `...` используется для развертывания массивов, объектов или строк на отдельные элементы, а также для копирования массивов или объектов.\n\nСинтаксис оператора `spread`:\n\n```javascript\nconst array1 = [...array]\n```\n\nЗдесь оператор `...` перед массивом `array` разворачивает его элементы и создает новый массив `array1`, содержащий те же элементы.\n\nВажно отметить, что при таком подходе создается новый массив, а не просто ссылка на существующий массив, поэтому изменения в копии массива не затронут оригинал.\n\nОднако, как уже упоминалось, если массив содержит объекты, то создается поверхностная копия, то есть новый массив будет содержать те же ссылки на объекты, что и оригинал. Если вы измените свойства одного из объектов, это изменение также будет видно и в оригинальном массиве и в его копии:\n\n```javascript\nconst f1 = [{name: 'Alex'}, {name: 'Joe'}];\n\nconst f2 = [...f1];\n\nf1[0].name = 'Abb'\n\nconsole.log(f2); // [{name: 'Abb'}, {name: 'Joe'}], поменялся\nconsole.log(f1); // [{name: 'Abb'}, {name: 'Joe'}], поменялся\n```\n\nРассмотрим пример использования оператора `...` с массивом содержащим примитивные типы данных :\n\n```javascript\nconst f1 = [1, 2, 3, 4, 5];\n\nconst f2 = [...f1];\n\nconsole.log(f2); // [1, 2, 3, 4, 5]\nconsole.log(f2 === f1); // false\n\nf1[0] = 200 // изменяем первый элемент в массиве f1\n\nconsole.log(f2); // [1, 2, 3, 4, 5], f2 не изменился\nconsole.log(f1); // [200, 2, 3, 4, 5]\n```\n\nС использованием оператора `...` мы можем копировать элементы массива сколько угодно раз.\nРассмотрим пример :\n\n```javascript\nconst f1 = [1, 2, 3, 4, 5];\n\nconst f2 = [...f1, ...f1];\n\nconsole.log(f2); // [1, 2, 3, 4, 5, 1, 2, 3, 4, 5]\nconsole.log(f1); // [1, 2, 3, 4, 5]\n```\n",
    "en": "Copying an array is an important operation when working with arrays. You may need it in various situations, for example when you want to save a copy of the original array for later use, without changing the original array.\n\nLet's look at an example:\n\n```javascript\nconst f1 = ['Bill', 'Alice', 'Carson', 'KJ', 'Viktor'];\n\nconst f2 = f1;\n\nconsole.log(f2); // ['Bill', 'Alice', 'Carson', 'KJ', 'Viktor']\nconsole.log(f1 === f2); // true\n\nf1[0] = 'Bob'; // change the first element in the array f1\n\nconsole.log(f2); // ['Bob', 'Alice', 'Carson', 'KJ', 'Viktor']\nconsole.log(f1); // ['Bob', 'Alice', 'Carson', 'KJ', 'Viktor']\n```\n\nIn this example, the `f2` array is a reference to the `f1` array, not a copy of it. Therefore, if `f2` is changed, `f1` will also be changed, and vice versa.\n\nThis behavior is due to the fact that in JavaScript the primitive data types (e.g., numbers, strings, boolean values) are copied by value, not by reference, while arrays and objects are copied by reference. This means that when you assign a variable to an array or object, it does not create a new object, but only a new reference to an existing object.\n\nThere are several ways to copy arrays, let's consider them in detail.\n\n### The `slice()` method\n\nThe `slice()` method is used to create a new array containing a copy of part or all of the original array.\n\nThe syntax of the `slice()` method:\n\n```javascript\narray.slice(begin, end)\n```\n\nThe `begin` and `end` arguments are optional and specify the start and end indexes between which the array elements should be copied. If no arguments are specified, the `slice()` method will copy the whole array.\n\nThe `slice()` method does not change the original array, but returns a new array.\n\n```javascript\nconst f1 = ['Bill', 'Alice', 'Carson', 'KJ', 'Viktor'];\n\nconst f2 = f1.slice();\n\nconsole.log(f2); // ['Bill', 'Alice', 'Carson', 'KJ', 'Viktor']\nconsole.log(f2 === f1); // false\n\nf1[0] = 'Bob'; // change the first element in the array f1\n\nconsole.log(f2); // ['Bill', 'Alice', 'Carson', 'KJ', 'Viktor'], f2 has not changed\nconsole.log(f1); // ['Bob', 'Alice', 'Carson', 'KJ', 'Viktor']\n```\n\nConsider the disadvantages of this method :\n\n```javascript\nconst f1 = [{name: 'Alex'}, {name: 'Joe'}];\n\nconst f2 = f1.slice();\n\nconsole.log(f2); // [{name: 'Alex'}, {name: 'Joe'}]\nconsole.log(f2 === f1); // false\n\nf1[0].name = 'Viktor'; // change the name in the first element in the f1 array\n\nconsole.log(f2); // [{name: 'Viktor'}, {name: 'Joe'}], f2 has changed\nconsole.log(f1); // [{name: 'Viktor'}, {name: 'Joe'}]\n```\n\nWe see that the `f2` array has also changed and now contains an object with the changed `name` property.\n\nThis is because the `slice()` method only copies the values of the array elements, not their references. In this case, when we copy an array, we copy references to objects contained in the array. So when we change an object property in `f1`, this change is also reflected in `f2`, because both arrays contain a reference to the same object.\n\nTo avoid this problem, you must create a complete copy of the objects contained in the array.\n\n`JSON.stringify()` and `JSON.parse()` are methods that are used to convert data into `JSON` format and back.\n\n* `JSON.stringify()` takes an object or array and converts it to a JSON string.\n* `JSON.parse()` takes a JSON string and converts it to an object or array.\n\n```javascript\nconst f1 = [{name: 'Alex'}, {name: 'Joe'}];\n\nconst f1String = JSON.stringify(f1);\n\nconsole.log(f1String); // '[{name: 'Alex'}, {name: 'Joe'}]' - string\nconsole.log(typeof f1String); // string\nconsole.log(f1String[0]); // '['\nconsole.log(f1); // [{name: 'Viktor'}, {name: 'Joe'}] is an array\n\nconst f2 = JSON.parse(f1String)\nconsole.log(f2); // [{name: 'Viktor'}, {name: 'Joe'}] - array\nconsole.log(f1); // [{name: 'Viktor'}, {name: 'Joe'}] - array\n\nconsole.log(f2 === f1); // false\n\n//check or now if we change the name in the first element f1 will change f2\nf1[0].name = 'Abb'\n\nconsole.log(f2); // [{name: 'Viktor'}, {name: 'Joe'}], not changed\nconsole.log(f1); // [{name: 'Abb'}, {name: 'Joe'}], changed\n```\n\nYou can also use the `spread` operator to copy an array.\n\n### Spread operator `...`\n\nThe spread `...` operator is used to expand arrays, objects or strings into individual elements, as well as to copy arrays or objects.\n\nThe syntax of the `spread` operator:\n\n```javascript\nconst array1 = [...array]\n```\n\nHere the `...` operator before the `array` array unfolds its elements and creates a new `array1` array containing the same elements.\n\nIt is important to note that this approach creates a new array, not just a reference to an existing array, so changes to the copy of the array will not affect the original.\n\nHowever, as already mentioned, if an array contains objects, a surface copy is created, that is, the new array will contain the same object references as the original. If you change the properties of one of the objects, this change will also be visible in the original array and its copy:\n\n```javascript\nconst f1 = [{name: 'Alex'}, {name: 'Joe'}];\n\nconst f2 = [...f1];\n\nf1[0].name = 'Abb'\n\nconsole.log(f2); // [{name: 'Abb'}, {name: 'Joe'}], changed\nconsole.log(f1); // [{name: 'Abb'}, {name: 'Joe'}], changed\n```\n\nConsider an example of using the `...` operator with an array containing primitive data types:\n\n```javascript\nconst f1 = [1, 2, 3, 4, 5];\n\nconst f2 = [...f1];\n\nconsole.log(f2); // [1, 2, 3, 4, 5]\nconsole.log(f2 === f1); // false\n\nf1[0] = 200 // change the first element in the f1 array\n\nconsole.log(f2); // [1, 2, 3, 4, 5], f2 has not changed\nconsole.log(f1); // [200, 2, 3, 4, 5]\n```\n\nUsing the `...` operator, we can copy the elements of an array as many times as we like.\nConsider the example :\n\n```javascript\nconst f1 = [1, 2, 3, 4, 5];\n\nconst f2 = [...f1, ...f1];\n\nconsole.log(f2); // [1, 2, 3, 4, 5, 1, 2, 3, 4, 5]\nconsole.log(f1); // [1, 2, 3, 4, 5]\n```\n",
    "es": "# Копирование массивов language: es"
  },
  "video": {
    "ru": "https://youtu.be/_-Uovngodhs",
    "en": "",
    "es": ""
  }
}