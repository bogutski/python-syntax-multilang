{
  "_id": "6696c2ca763f0712c198e64c",
  "content": {
    "ru": "`Типы данных` в JavaScript делятся на `примитивные` и `сложные или составные` типы.\n\n#### Примитивные типы данных\n\nВ переменную `примитивного типа` могут быть записаны только простые значения.\n\nПримеры примитивных типов данных: `number`, `string`, `boolean`.\n\n```javascript\nconst name = 'Bobby'; // string\nconst num = 456; // number\nconst isAvailable = true; // boolean\n```\n\nПри `копировании примитивных типов данных` - копируется все значение целиком и получаются две независимые переменные.\n\nРассмотрим пример копирования переменной типа `number`:\n\n```javascript\nconst num = 456;\nconst copy = num;\n\nconsole.log(num); // 456\nconsole.log(copy); // 456\n```\n\nВ переменную `copy` записана копия переменной `num`.\n\nПеременные `num` и `copy` независимы друг от друга.\n\nИзменение значения одной переменной никак не отобразится на другой.\n\n```javascript\ncopy = 100;\n\nconsole.log(num); // 456\nconsole.log(copy); // 100\n```\n\nВ переменную `copy` записано новое значение `100`. Переменная `num` не изменилась.\n\nКопирование переменных типа `string` происходит аналогично.\n\n```javascript\nconst greeting = 'Welcome Bobby!';\nlet message = greeting;\n\nconsole.log(greeting); // \"Welcome Bobby!\"\nconsole.log(message); // \"Welcome Bobby!\"\n```\n\nСозданы 2 переменные типа `string` - `greeting` и `message`. Переменная `message` - копия переменной `greeting`.\n\nВ обеих переменных хранятся одинаковые значения `'Welcome Bobby!'`. Эти два значения не связаны между собой.\n\nИзменяя одну переменную, мы не меняем другую.\n\n```javascript\nmessage = 'Hello Bobby!';\n\nconsole.log(greeting); // \"Welcome Bobby!\"\nconsole.log(message); // \"Hello Bobby!\"\n```\n\n### Сложные или составные типы данных\n\nВ переменных `сложных или составных типов` могут храниться целые коллекции данных.\n\nНе примитивные типы данных в JavaScript представлены `объектами`.\n\n`Объекты` - это своего рода строительные блоки, на основании которых в JavaScript могут определяться другие типы данных, например, `Array`, который мы рассмотрим подробнее в следующем разделе курса.\n\nОбъекты также называют `ссылочными` типами данных (`reference type`).\n\nОсновное отличие объектов от примитивных типов - объекты хранятся и копируются по ссылке, а не как одно значение.\n\nПри объявлении переменной `типа объект` в памяти компьютера выделяется `место` для хранения этого объекта и всей записанной в него информации.\n\nВ созданную переменную записывается не значение объекта, а `ссылка`, адрес или указатель на место в памяти компьютера, где создан объект.\n\n```javascript\nconst car = {\n  id: 123,\n};\n```\n\nСоздан новый объект, имеющий одно свойство `id` со значением `123`.\n\nСоздана переменная `car` типа `object`.\n\nВ переменную `car` записана ссылка на место в памяти компьютера, где размещен созданный объект.\n\nЧерез переменную `car` можно обращаться к свойствам объекта: читать и изменять их значения, удалять, добавлять новые свойства и т.д.\n\n#### Существует принципиальная разница между копированием примитивных типов данных и объектов.\n\nПри попытке копирования объектов через присваивание - `копируются ссылки` - копии объектов не создаются.\n\nДавайте рассмотрим пример:\n\n```javascript\nconst car = {\n  id: 123,\n};\n\nconsole.log(car); // {id: 123}\n\nconst box = car;\n\nconsole.log(box); // {id: 123}\n```\n\nПри присваивании переменной `box` значения `car` не создается физическая копия объекта.\n\nВ переменную `box` записывается `копия ссылки` на уже существующий объект `car`.\n\nВ результате в обеих переменных записаны ссылки на один и тоже объект, но объект всего один.\n\nТеперь можно через любую из этих переменных обращаться к объекту для получения или изменения его свойств.\n\n```javascript\ncar.vin = 44444444444;\n\nconsole.log(car); //{id: 123, vin: 44444444444}\nconsole.log(box); //{id: 123, vin: 44444444444}\n```\n\nТак как обе переменные указывают на один и тот же объект, после добавления нового свойства `vin` через переменную `car` мы видим эти изменения, обращаясь к объекту через переменную `box`.\n\n```javascript\nbox.vin = 55555555555;\n\nconsole.log(car); //{id: 123, vin: 55555555555}\nconsole.log(box); //{id: 123, vin: 55555555555}\n```\n\nИ наоборот, после изменения свойства `vin` через переменную `box` мы видим эти изменения, обращаясь к объекту через переменную `car`.\n\nДля копирования объектов такой способ не работает - нужно использовать другие методы.\n\n### Сравнение объектов\n\nПри сравнении переменных типа `object` сравниваются ссылки, а не значения, записанные внутри объектов.\n\n```javascript\nconst car = {\n  id: 123,\n};\n\nconst box = car;\n\nconsole.log(box === car); // true\n```\n\nСсылки в переменных `box` и `car` одинаковые, поэтому результат их сравнения - `true`.\n\n```javascript\nconst car = {};\nconst box = {};\n\nconsole.log(box === car); // false\n```\n\nСоздано 2 пустых объекта. Они выглядят одинаково, и можно ошибочно предположить, что результат их сравнения должен быть `true`.\n\nНа самом деле для каждого вновь созданного объекта выделяется `свое` место в памяти, поэтому адреса-ссылки у них разные.\n\nСравнение двух отличающихся ссылок возвращает `false`.\n\n```javascript\nconsole.log({} === {}); // false\n\nconsole.log({} == {}); // false\n```\n\nДля сравнения объектов нужно сравнивать их свойства-ключи и записанные в них значения.\n\nНужно проверять, что для каждого свойства одного объекта существует соответствующее свойство в другом объекте.\n\nДля равенства объектов значения одноименных свойств в обоих объектах должны быть равны друг другу.\n\n```javascript\nconst car = { id: 10 };\nconst box = { id: 10 };\n\nconsole.log(box.id === car.id); // true\n```\n\nВ этом примере сравниваются примитивные значения - числа, записанные в объекты.\n\nЧисла равны, поэтому результат сравнения -`true`.\n\nТаким образом, чтобы сравнить 2 объекта, нужно `сравнить все их свойства`.\n\nЕсли в объекте не очень много свойств, то их можно перебрать по одному.\n\n```javascript\nconst car = { id: 10, price: 45 };\nconst box = { id: 10, price: 44 };\n\nconsole.log(box.id === car.id && box.price === car.price); // false\n```\n\nОбъекты `car` и `box` не равны друг другу, потому что в их свойствах `price` записаны разные значения.\n\n```javascript\nconst car = { id: 10, price: 45 };\nconst box = { id: 10, price: 45 };\n\nconsole.log(box.id === car.id && box.price === car.price); // true\n```\n\nОбъекты `car` и `box` равны, поскольку у каждого из них есть 2 одинаковых свойства `id` и `price`с одинаковыми значениями.\n\nДля объектов с более сложной структурой в JavaScript существуют другие встроенные механизмы сравнения.\n\nДля сравнения объектов, содержащих в себе другие вложенные объекты, можно воспользоваться методом `JSON.stringify()`, который конвертирует переданный объект в строку.\n\n### Копирование объектов\n\nДля получения копии объекта нужно скопировать все его свойства в новый пустой объект.\n\nВ результате мы получаем 2 объекта с одинаковым содержимым и разными ссылками.\n\n```javascript\nconst car = { id: 10, price: 44 };\nconst box = {};\n\nbox.id = car.id;\nbox.price = car.price;\n\nconsole.log(box); // { id: 10, price: 44 }\n\nconsole.log(box === car); // false\n```\n\nСоздан объект `car` с двумя свойствами `id` и `price`.\n\nСоздан новый пустой объект `box` и в него скопированы свойства `id` и `price` из объекта `car`.\n\nТаким образом получено 2 идентичных объекта, размещенных по разным адресам в памяти компьютера.\n\nСравнение переменных `box` и `car` возвращает `false`, потому что сравниваются ссылки, указывающие на разные адреса памяти.\n\n```javascript\nbox.id = 1010;\n\nconsole.log(box); // { id: 1010, price: 44 }\nconsole.log(car); // { id: 10, price: 44 }\n\ncar.price = 55;\n\nconsole.log(car); // { id: 10, price: 55 }\nconsole.log(box); // { id: 1010, price: 44 }\n```\n\nСозданные объекты `car` и `box` никак не связаны друг с другом - изменяя один из них, мы не меняем другой.\n\nРассмотрим еще один пример копирования объекта.\n\nПусть у нас есть объект `building`, имеющий следующую структуру:\n\n- `type`, тип здания - строка\n- `floors`, количество этажей - число\n- `address`, адрес - объект с двумя свойствами: `city` город и `streetNumber` название улицы и номер дома\n\nНапишем функцию `copyBuilding` которая будет принимать объект `building` и возвращать копию этого объекта:\n\n```javascript\nfunction copyBuilding(building) {\n  const newBuilding = {};\n  newBuilding.type = building.type;\n  newBuilding.floors = building.floors;\n  newBuilding.address = {};\n  newBuilding.address.city = building.address.city;\n  newBuilding.address.streetNumber = building.address.streetNumber;\n  return newBuilding;\n}\n\nconst building1 = {\n  type: 'residence',\n  floors: 2,\n  address: {\n    city: 'New York',\n    streetNumber: '23 Belt ln',\n  },\n};\n\nconsole.log(copyBuilding(building1));\n// { address: {city: \"New York\", streetNumber: \"23 Belt ln\"}, floors: 2, type: \"residence\"}\n```\n",
    "en": "`Data types` in JavaScript are divided into `primitive` and `complex or compound` types.\n\n#### Primitive data types\n\nOnly simple values can be written to a `primitive type` variable.\n\nExamples of primitive data types: `number`, `string`, `boolean`.\n\n```javascript\nconst name = 'Bobby'; // string\nconst num = 456; // number\nconst isAvailable = true; // boolean\n```\n\nWhen `copying primitive data types` - the whole value is copied and you get two independent variables.\n\nConsider the example of copying a variable of type `number`:\n\n```javascript\nconst num = 456;\nconst copy = num;\n\nconsole.log(num); // 456\nconsole.log(copy); // 456\n```\n\nThe `copy` variable contains a copy of the `num` variable.\n\nThe `num` and `copy` variables are independent of each other.\n\nChanging the value of one variable will have no effect on the other.\n\n```javascript\ncopy = 100;\n\nconsole.log(num); // 456\nconsole.log(copy); // 100\n```\n\nA new value of `100` is written to the `copy` variable. The variable `num` has not changed.\n\nThe copying of variables of type `string` is done in the same way.\n\n```javascript\nconst greeting = 'Welcome Bobby!';\nlet message = greeting;\n\nconsole.log(greeting); // \"Welcome Bobby!\"\nconsole.log(message); // \"Welcome Bobby!\"\n```\n\nThere are 2 variables of type `string` - `greeting` and `message`. The variable `message` is a copy of the variable `greeting`.\n\nBoth variables store the same value of `'Welcome Bobby!'` The two values are unrelated.\n\nBy changing one variable, we do not change the other.\n\n```javascript\nmessage = 'Hello Bobby!';\n\nconsole.log(greeting); // \"Welcome Bobby!\"\nconsole.log(message); // \"Hello Bobby!\"\n```\n\n### Complex or compound data types\n\nVariables of `complex or compound types` can store entire collections of data.\n\nNon-primitive data types in JavaScript are represented by `objects`.\n\nThe `Objects` are a kind of building blocks, based on which JavaScript can define other types of data, such as `Array`, which we will look at in more detail in the next section of the course.\n\nObjects are also called `reference` data types.\n\nThe main difference between objects and primitive types is that objects are stored and copied by reference, not as a single value.\n\nWhen you declare a variable `type object` in computer memory, a `space` is allocated to store that object and all information written to it.\n\nIt is not the value of the object that is written to the created variable, but a `link`, an address or pointer to the location in computer memory where the object was created.\n\n```javascript\nconst car = {\n  id: 123,\n};\n```\n\nA new object has been created that has one property `id` with a value of `123`.\n\nA variable `car` of type `object` is created.\n\nThe `car` variable contains a reference to the place in computer memory where the created object is located.\n\nThrough the `car` variable you can access object properties: read and change their values, delete, add new properties, etc.\n\n#### There is a fundamental difference between copying primitive data types and objects.\n\nWhen you try to copy objects through assignment - `copy references` - no object copies are created.\n\nLet's look at an example:\n\n```javascript\nconst car = {\n  id: 123,\n};\n\nconsole.log(car); // {id: 123}\n\nconst box = car;\n\nconsole.log(box); // {id: 123}\n```\n\nAssigning the `box` variable to `car` does not create a physical copy of the object.\n\nThe `box` variable contains a `copy` of a reference to an already existing `car` object.\n\nAs a result, both variables contain references to the same object, but there is only one object.\n\nYou can now access an object through any of these variables to retrieve or change its properties.\n\n```javascript\ncar.vin = 44444444444;\n\nconsole.log(car); //{id: 123, vin: 44444444444}\nconsole.log(box); //{id: 123, vin: 44444444444}\n```\n\nSince both variables point to the same object, after adding a new property `vin` through the `car` variable we see these changes by accessing the object through the `box` variable.\n\n```javascript\nbox.vin = 55555555555;\n\nconsole.log(car); //{id: 123, vin: 55555555555}\nconsole.log(box); //{id: 123, vin: 55555555555}\n```\n\nConversely, after changing the `vin` property through the `box` variable, we see these changes by accessing the object through the `car` variable.\n\nIt doesn't work for copying objects - you have to use other methods.\n\n### Comparing objects\n\nWhen comparing variables of type `object`, references are compared, not values written inside objects.\n\n```javascript\nconst car = {\n  id: 123,\n};\n\nconst box = car;\n\nconsole.log(box === car); // true\n```\n\nThe references in the `box` and `car` variables are the same, so the result of their comparison is `true`.\n\n```javascript\nconst car = {};\nconst box = {};\n\nconsole.log(box === car); // false\n```\n\nTwo empty objects are created. They look the same, and it can be mistakenly assumed that the result of their comparison should be `true`.\n\nIn fact, each newly created object is allocated its `own` memory space, so they have different address-references.\n\nComparing two different references returns `false`.\n\n```javascript\nconsole.log({} === {}); // false\n\nconsole.log({} == {}); // false\n```\n\nTo compare objects, you need to compare their properties-keys and the values written in them.\n\nWe need to check that for each property of one object there is a corresponding property in the other object.\n\nFor objects to be equal, the values of the same property in both objects must be equal to each other.\n\n```javascript\nconst car = { id: 10 };\nconst box = { id: 10 };\n\nconsole.log(box.id === car.id); // true\n```\n\nThis example compares primitive values - numbers written in objects.\n\nThe numbers are equal, so the result of the comparison is `true`.\n\nThus, to compare 2 objects, you need to `compare all their properties`.\n\nIf the object does not have very many properties, you can go through them one by one.\n\n```javascript\nconst car = { id: 10, price: 45 };\nconst box = { id: 10, price: 44 };\n\nconsole.log(box.id === car.id && box.price === car.price); // false\n```\n\nThe objects `car` and `box` are not equal to each other, because their `price` properties have different values.\n\n```javascript\nconst car = { id: 10, price: 45 };\nconst box = { id: 10, price: 45 };\n\nconsole.log(box.id === car.id && box.price === car.price); // true\n```\n\nThe objects `car` and `box` are equal because they each have 2 of the same properties `id` and `price` with the same values.\n\nFor objects with a more complex structure, JavaScript has other built-in comparison mechanisms.\n\nTo compare objects containing other nested objects, you can use the `JSON.stringify()` method, which converts the passed object to a string.\n\n### Copying objects\n\nTo get a copy of an object, copy all its properties to a new empty object.\n\nAs a result, we get two objects with the same content and different references.\n\n```javascript\nconst car = { id: 10, price: 44 };\nconst box = {};\n\nbox.id = car.id;\nbox.price = car.price;\n\nconsole.log(box); // { id: 10, price: 44 }\n\nconsole.log(box === car); // false\n```\n\nAn object `car` was created with two properties `id` and `price`.\n\nA new empty object `box` was created and the properties `id` and `price` from the object `car` were copied into it.\n\nThus we obtained 2 identical objects placed at different addresses in the computer memory.\n\nComparing the `box` and `car` variables returns `false` because they are comparing references pointing to different memory addresses.\n\n```javascript\nbox.id = 1010;\n\nconsole.log(box); // { id: 1010, price: 44 }\nconsole.log(car); // { id: 10, price: 44 }\n\ncar.price = 55;\n\nconsole.log(car); // { id: 10, price: 55 }\nconsole.log(box); // { id: 1010, price: 44 }\n```\n\nThe created objects `car` and `box` are not related to each other in any way - changing one of them does not change the other.\n\nConsider another example of copying an object.\n\nSuppose we have a `building` object that has the following structure:\n\n- `type`, building type - string\n- `floors`, number of floors - number\n- `address`, address - object with two properties: `city` and `streetNumber`\n\nLet's write a function `copyBuilding` that will take a `building` object and return a copy of that object:\n\n```javascript\nfunction copyBuilding(building) {\n  const newBuilding = {};\n  newBuilding.type = building.type;\n  newBuilding.floors = building.floors;\n  newBuilding.address = {};\n  newBuilding.address.city = building.address.city;\n  newBuilding.address.streetNumber = building.address.streetNumber;\n  return newBuilding;\n}\n\nconst building1 = {\n  type: 'residence',\n  floors: 2,\n  address: {\n    city: 'New York',\n    streetNumber: '23 Belt ln',\n  },\n};\n\nconsole.log(copyBuilding(building1));\n// { address: {city: \"New York\", streetNumber: \"23 Belt ln\"}, floors: 2, type: \"residence\"}\n```\n",
    "es": "# Ссылочный тип данных. Копирование объектов language: es"
  },
  "video": {
    "ru": "https://youtu.be/pZR6cPjl66U",
    "en": "",
    "es": ""
  }
}