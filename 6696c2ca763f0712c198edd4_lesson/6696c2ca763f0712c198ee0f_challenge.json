{
  "_id": "6696c2ca763f0712c198ee0f",
  "name": {
    "en": "Decipher the abbreviated street names",
    "ru": "Расшифровать сокращенные названия улиц"
  },
  "instruction": {
    "en": "In postal addresses, abbreviated street names are often used for brevity. There is an official table for decoding these abbreviations. For example, here are some of them:\n\n* St. = Street\n* Rd. = Road\n* Ln. = Lane\n* Dr. = Drive\n* Cir. = Circle\n* Ave. = Avenue\n* Pl. = Place\n* Sq. = Square\n* Pkwy. = Parkway\n* Ct. = Court\n* Hwy. = Highway\n* Plz. = Plaza\n* Blvd. = Boulevard\n* Bch. = Beach\n* Aly. = Alley\n\nIn fact, the table is quite large, but for the purpose of this task, we will only use the 15 abbreviations listed above.\n\nYou need to write a function `decodeAddress` that takes a string with an abbreviated address and returns a string that includes the address with the full street name.\n\nThe words in the string are separated by spaces. In a loop, you need to extract words from the string and compare them with the values in the table. If the word is in the table, it should be replaced with the full name from the table; otherwise, it should be left unchanged. It is not known in advance in what order the words will appear in the string, so each word needs to be checked.\n\nIf you have forgotten the algorithm for extracting words from a string, review the lesson \"Extracting Numbers from a String\". The solution is not allowed to use string methods: `split`, `replace`, `indexOf`, `lastIndexOf`, `includes`.\n\nExamples:\n```javascript\ndecodeAddress('123 Main St.') // '123 Main Street'\ndecodeAddress('1001 1st Ave.') // '1001 1st Avenue'\ndecodeAddress('55 North Center Drive') // '55 North Center Drive'\ndecodeAddress('') // ''\n```\nTo store the table, we will create an object `decodeTable`, where the abbreviations will be the keys and the full names will be the values.\n```javascript\nconst decodeTable = {\n  'St.': 'Street',\n  'Rd.': 'Road',\n  'Ln.': 'Lane',\n  'Dr.': 'Drive',\n  'Cir.': 'Circle',\n  'Ave.': 'Avenue',\n  'Pl.': 'Place',\n  'Sq.': 'Square',\n  'Pkwy.': 'Parkway',\n  'Ct.': 'Court',\n  'Hwy.': 'Highway',\n  'Plz.': 'Plaza',\n  'Blvd.': 'Boulevard',\n  'Bch.': 'Beach',\n  'Aly.': 'Alley',\n}\n```",
    "ru": "В почтовых адресах для краткости часто используются сокращенные названия улиц.\nСуществует официальная таблица для расшифровки этих сокращений.\nДля примера, вот некоторые из них:\n\n* St. = Street\n* Rd. = Road\n* Ln. = Lane\n* Dr. = Drive\n* Cir. = Circle\n* Ave. = Avenue\n* Pl. = Place\n* Sq. = Square\n* Pkwy. = Parkway\n* Ct. = Court\n* Hwy. = Highway\n* Plz. = Plaza\n* Blvd. = Boulevard\n* Bch. = Beach\n* Aly. = Alley\n\nНа самом деле, таблица довольно большая, но для решения этой задачи мы будем использовать только 15 сокращений, которые указаны выше.\n\nНужно написать функцию `decodeAddress`, которая принимает строку с сокращенным адресом и возвращает строку, включающую адрес с полным названием улицы.\n\nСлова в строке разделены пробелами.\nНужно в цикле получать из строки слова и сравнивать их со значениями в таблице.\nЕсли слово есть в таблице, то нужно заменить его на полное название из таблицы, если нет, то оставить без изменений.\nЗаведомо не известно, в каком порядке будут идти слова в строке, поэтому нужно проверять каждое слово.\n\nЕсли вы забыли алгоритм получения слов из строки, пересмотрите урок `Получить числа из строки`.\nВ решении запрещено использовать методы строк: `split`, `replace`, `indexOf`, `lastIndexOf`, `includes`.\n\nПримеры запуска:\n```javascript\ndecodeAddress('123 Main St.') // '123 Main Street'\ndecodeAddress('1001 1st Ave.') // '1001 1st Avenue'\ndecodeAddress('55 North Center Drive') // '55 North Center Drive'\ndecodeAddress('') // ''\n```\nДля хранения таблицы создадим объект `decodeTable`, в котором сокращения будут являться ключами, а полные названия - значениями.\n```javascript\nconst decodeTable = {\n  'St.': 'Street',\n  'Rd.': 'Road',\n  'Ln.': 'Lane',\n  'Dr.': 'Drive',\n  'Cir.': 'Circle',\n  'Ave.': 'Avenue',\n  'Pl.': 'Place',\n  'Sq.': 'Square',\n  'Pkwy.': 'Parkway',\n  'Ct.': 'Court',\n  'Hwy.': 'Highway',\n  'Plz.': 'Plaza',\n  'Blvd.': 'Boulevard',\n  'Bch.': 'Beach',\n  'Aly.': 'Alley',\n}\n```"
  },
  "initialSolution": "function decodeAddress(address) {\n  const decodeTable = {\n    'St.': 'Street',\n    'Rd.': 'Road',\n    'Ln.': 'Lane',\n    'Dr.': 'Drive',\n    'Cir.': 'Circle',\n    'Ave.': 'Avenue',\n    'Pl.': 'Place',\n    'Sq.': 'Square',\n    'Pkwy.': 'Parkway',\n    'Ct.': 'Court',\n    'Hwy.': 'Highway',\n    'Plz.': 'Plaza',\n    'Blvd.': 'Boulevard',\n    'Bch.': 'Beach',\n    'Aly.': 'Alley'\n  }\n\n}",
  "completedSolution": "function decodeAddress(address) {\n  const decodeTable = {\n    'St.': 'Street',\n    'Rd.': 'Road',\n    'Ln.': 'Lane',\n    'Dr.': 'Drive',\n    'Cir.': 'Circle',\n    'Ave.': 'Avenue',\n    'Pl.': 'Place',\n    'Sq.': 'Square',\n    'Pkwy.': 'Parkway',\n    'Ct.': 'Court',\n    'Hwy.': 'Highway',\n    'Plz.': 'Plaza',\n    'Blvd.': 'Boulevard',\n    'Bch.': 'Beach',\n    'Aly.': 'Alley',\n  }\n\n  let result ='';\n  let word = '';\n  for (let i = 0; i < address.length; i++) {\n    const char = address[i];\n    if (char === ' '){\n      if(word in decodeTable){\n        result += decodeTable[word];\n      } else {\n        result += word;\n      }\n      result += char;\n      word = '';\n    } else {\n      word += char;\n    }\n  }\n  if(word) {\n    result += word in decodeTable ? decodeTable[word] : word;\n  }\n  return result;\n}",
  "openTest": "it('Created function decodeAddress', () => {\n  expect(decodeAddress).to.be.a('function');\n});\n\nit('Function decodeAddress should not use split()', () => {\n  expect(decodeAddress.toString()).to.not.include('.split(');\n});\n\nit('Function decodeAddress should not use replace()', () => {\n  expect(decodeAddress.toString()).to.not.include('.replace(');\n})\n\nit('Function decodeAddress should not use indexOf()', () => {\n  expect(decodeAddress.toString()).to.not.include('.indexOf(');\n});\n\nit('Function decodeAddress should not use lastIndexOf()', () => {\n  expect(decodeAddress.toString()).to.not.include('.lastIndexOf(');\n});\n\nit('Function decodeAddress should not use join()', () => {\n  expect(decodeAddress.toString()).to.not.include('.join(');\n});\n\nit('decodeAddress(\"123 Main St.\") should return \"123 Main Street\"', () => {\n  expect(decodeAddress('123 Main St.')).to.equal('123 Main Street');\n});\n\nit('decodeAddress(\"1001 1st Ave.\") should return \"1001 1st Avenue\"', () => {\n  expect(decodeAddress('1001 1st Ave.')).to.equal('1001 1st Avenue');\n});\n\nit('decodeAddress(\"3413 Wood Aly.\") should return \"3413 Wood Alley\"', () => {\n  expect(decodeAddress('3413 Wood Aly.')).to.equal('3413 Wood Alley');\n});\n\nit('decodeAddress(\"551 North Center Pkwy.\") should return \"551 North Center Parkway\"', () => {\n  expect(decodeAddress('551 North Center Pkwy.')).to.equal('551 North Center Parkway');\n});\n\nit('decodeAddress(\"5051 North Center Parkway\") should return \"5051 North Center Parkway\"', () => {\n  expect(decodeAddress('5051 North Center Parkway')).to.equal('5051 North Center Parkway');\n});\n\nit('decodeAddress(\"55 North Center Dr.\") should return \"55 North Center Drive\"', () => {\n  expect(decodeAddress('55 North Center Dr.')).to.equal('55 North Center Drive');\n});\n\nit('decodeAddress(\"\") should return \"\"', () => {\n  expect(decodeAddress('')).to.equal('');\n});\n\nit('decodeAddress(\"123 Main St. 1001 1st Ave. 505 Floyd Dr.\") should return \"123 Main Street 1001 1st Avenue 505 Floyd Drive\"', () => {\n  expect(decodeAddress('123 Main St. 1001 1st Ave. 505 Floyd Dr.')).to.equal('123 Main Street 1001 1st Avenue 505 Floyd Drive');\n});",
  "hiddenTest": "",
  "programmingLang": "JavaScript",
  "status": "new",
  "level": "Easy",
  "showOpenTest": true,
  "active": false,
  "checker": "unit",
  "hint": {
    "en": "",
    "ru": ""
  }
}