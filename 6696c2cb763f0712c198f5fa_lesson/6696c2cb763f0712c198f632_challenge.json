{
  "_id": "6696c2cb763f0712c198f632",
  "name": {
    "en": "/*",
    "ru": "Сортировка городов по населению и названию"
  },
  "instruction": {
    "en": "",
    "ru": "Напишите функцию `sortCities`, которая принимает массив объектов, представляющих города.\n\nКаждый объект содержит свойства `name` (название города) и `population` (население города).\n\nФункция должна возвращать новый массив, где города отсортированы сначала по населению (по убыванию), а при одинаковом населении — по названию города в алфавитном порядке.\n\nИсходный массив должен оставаться неизменным.\n\n\nПримеры запуска функции:\n```javascript\nconsole.log(sortCities([\n  { name: \"Smallville\", population: 10000 },\n  { name: \"Metropolis\", population: 1000000 },\n  { name: \"Gotham\", population: 1000000 }\n]));\n// Вывод: [\n//    { name: \"Gotham\", population: 1000000 },\n//    { name: \"Metropolis\", population: 1000000 },\n//    { name: \"Smallville\", population: 10000 }\n// ]\n\nconsole.log(sortCities([\n  { name: \"Springfield\", population: 50000 },\n  { name: \"Shelbyville\", population: 50000 }\n]));\n// Вывод: [\n//    { name: \"Shelbyville\", population: 50000 },\n//    { name: \"Springfield\", population: 50000 }\n// ]\n```"
  },
  "initialSolution": "function sortCities(){\n\n}",
  "completedSolution": "function sortCities(arr) {\n  return arr.toSorted((a, b) => {\n    if(a.population === b.population) return a.name.localeCompare(b.name)\n    else return b.population - a.population\n  });\n}",
  "openTest": "Array.prototype.toSorted = function(compareFunction){\n  const newArray = this.slice()\n  if(compareFunction) return newArray.sort(compareFunction)\n  else return newArray.sort()\n}\n\nit('Created function sortCities', () => {\n  expect(sortCities).to.be.a('function');\n});\n\nit('Function sortCities should include method toSorted()', () => {\n  const res = sortCities.toString()\n  expect(res).to.include('.toSorted(')\n});\n\nit('Function sortCities should not include method sort()', () => {\n  const res = sortCities.toString()\n  expect(res).to.not.include('.sort(')\n});\n\nit(\"sortCities([{ name: 'Smallville', population: 10000 }, { name: 'Metropolis', population: 1000000 }, { name: 'Gotham', population: 1000000 }]) should sort by population descending, then by name alphabetically\", () => {\n  expect(sortCities([\n    { name: \"Smallville\", population: 10000 },\n    { name: \"Metropolis\", population: 1000000 },\n    { name: \"Gotham\", population: 1000000 }\n  ])).to.deep.equal([\n    { name: \"Gotham\", population: 1000000 },\n    { name: \"Metropolis\", population: 1000000 },\n    { name: \"Smallville\", population: 10000 }\n  ]);\n});\n\nit(\"sortCities([{ name: 'Springfield', population: 50000 }, { name: 'Shelbyville', population: 50000 }]) should sort by name alphabetically when populations are equal\", () => {\n  expect(sortCities([\n    { name: \"Springfield\", population: 50000 },\n    { name: \"Shelbyville\", population: 50000 }\n  ])).to.deep.equal([\n    { name: \"Shelbyville\", population: 50000 },\n    { name: \"Springfield\", population: 50000 }\n  ]);\n});\n\nit(\"sortCities([]) should return an empty array\", () => {\n  expect(sortCities([])).to.deep.equal([]);\n});\n\nit(\"sortCities([{ name: 'Lonelytown', population: 1 }]) should return the same single-city array\", () => {\n  expect(sortCities([{ name: 'Lonelytown', population: 1 }])).to.deep.equal([{ name: 'Lonelytown', population: 1 }]);\n});\n\nit(\"sortCities([{ name: 'B', population: 200 }, { name: 'A', population: 300 }]) should return sorted by population then name\", () => {\n  expect(sortCities([\n    { name: 'B', population: 200 },\n    { name: 'A', population: 300 }\n  ])).to.deep.equal([\n    { name: 'A', population: 300 },\n    { name: 'B', population: 200 }\n  ]);\n});\n\nit(\"sortCities([{ name: 'A', population: 300 }, { name: 'A', population: 200 }]) should sort by population only\", () => {\n  expect(sortCities([\n    { name: 'A', population: 300 },\n    { name: 'A', population: 200 }\n  ])).to.deep.equal([\n    { name: 'A', population: 300 },\n    { name: 'A', population: 200 }\n  ]);\n});\n\nit(\"sortCities([{ name: 'C', population: 150 }, { name: 'B', population: 150 }, { name: 'A', population: 150 }]) should sort alphabetically when populations are the same\", () => {\n  expect(sortCities([\n    { name: 'C', population: 150 },\n    { name: 'B', population: 150 },\n    { name: 'A', population: 150 }\n  ])).to.deep.equal([\n    { name: 'A', population: 150 },\n    { name: 'B', population: 150 },\n    { name: 'C', population: 150 }\n  ]);\n});\n\nit(\"sortCities([{ name: 'A', population: 150 }, { name: 'a', population: 150 }]) should consider case sensitivity in alphabetical sorting\", () => {\n  expect(sortCities([\n    { name: 'A', population: 150 },\n    { name: 'a', population: 150 }\n  ])).to.deep.equal([\n    { name: 'a', population: 150 },\n    { name: 'A', population: 150 }\n  ]);\n});",
  "hiddenTest": "",
  "programmingLang": "JavaScript",
  "status": "new",
  "level": "Easy",
  "showOpenTest": true,
  "active": false,
  "checker": "unit",
  "hint": {
    "en": "",
    "ru": ""
  }
}