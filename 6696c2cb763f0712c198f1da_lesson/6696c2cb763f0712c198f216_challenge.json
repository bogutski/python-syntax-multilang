{
  "_id": "6696c2cb763f0712c198f216",
  "name": {
    "en": "Divide an array into 2 subarrays with the same sum of elements",
    "ru": "Разделить массив на 2 подмассива с одинаковой суммой элементов"
  },
  "instruction": {
    "en": "Fix the errors in the code so that the `splitByEqualSum` function works correctly.\n\nThe `splitByEqualSum` function accepts an integer array and must return an array of two subarrays whose sum of numbers is equal.\nIf such a split does not exist or an empty array is passed to the function, the function must return an empty array.\n\nTo solve the problem, sum the elements of the array in the order they go in the array.\nIn a loop moving through the array from left to right, calculate the sums of the elements on the left and right and compare them.\nIf the sums are equal, remember the index of the place where this happened and divide the array into two parts by this index.\n\nExample calls:\n```javascript\nsplitByEqualSum([1, 2, 3, 4, 5, 5, 5]) // [[1, 2, 3, 4], [5, 5]] => 10 === 10\nsplitByEqualSum([-1, 2, 3, -4, 5]) // [[-1, 2, 3, -4], [ 5]] => 5 === 5\nsplitByEqualSum([1, 2, 3, 4]) // [] => no split possible\n```\n\nThere are several small errors in the solution, find and correct them.\n\nDissect the examples and the solution algorithm, check your solution on other values.\n\nThis is one of the problems that you may encounter in a job interview.\nThe given algorithm is not the only way to solve this problem, but it is simple and clear.\nYou can think how you can optimize it.\n\nAnother variant of this task that may come up in an interview: divide an array into three parts so that the sum of elements in the left part is less than the sum of elements in the center part, and the sum of elements in the center part is less than the sum of elements in the right part.",
    "ru": "Исправьте ошибки в коде, чтобы функция `splitByEqualSum` работала правильно.\n\nФункция `splitByEqualSum` принимает целочисленный массив и должна вернуть массив из двух подмассивов, сумма чисел в которых равна.\nЕсли такого разделения не существует или в функцию передан пустой массив, то функция должна вернуть пустой массив.\n\nДля решения задачи суммируйте элементы массива в том порядке, как они идут в массиве.\nВ цикле двигаясь по массиву слева направо, вычисляйте суммы элементов в левой и правой частях и сравнивайте их.\nЕсли суммы равны, запомните индекс места, где это произошло, и разделите массив на две части по этому индексу.\n\nПримеры вызовов:\n```javascript\nsplitByEqualSum([1, 2, 3, 4, 5, 5]) // [[1, 2, 3, 4], [5, 5]] => 10 === 10\nsplitByEqualSum([-1, 2, 3, -4, 5]) // [[-1, 2, 3, -4], [ 5]] => 5 === 5\nsplitByEqualSum([1, 2, 3, 4]) // [] => разделение невозможно\n```\n\nВ решении допущено несколько небольших ошибок, найдите и исправьте их.\n\nРазберите примеры и алгоритм решения, проверьте свое решение на других значениях.\n\nЭто одна из задач, которые могут попасться на собеседовании.\nПриведенный алгоритм - не единственный способ решения этой задачи, но он простой и понятный.\nМожете подумать, как можно его оптимизировать.\n\nДругой вариант этой задачи, который может попасться на интервью: разделить массив на три части так, чтобы сумма элементов в левой части была меньше суммы элементов в центральной части, а сумма элементов в центральной части была меньше суммы элементов в правой части."
  },
  "initialSolution": "Function splitByEqualSum(array) {\n  let leftSum = 0; // сумма элементов левой части массива - инициализируем нулем\n  let rightSum = 0; // сумма элементов правой части массива - инициализируем нулем\n  let index = -1; // индекс элемента, по которому будет происходить разделение массива, инициализируем -1, потому что элемента с таким индексом в массиве не существует\n\n  for (let i = 0; i < arr.length - 1; i++) { // обратите внимание, что цикл идет до предпоследнего элемента\n    leftSum += arr[i]; // сумма элементов слева от i-го элемента, включая его\n\n    rightSum = 0;   // обнуляем сумму элементов справа от i-го элемента\n    for (let j = i + 1; j < arr.lng; j++) { // вычисляем сумму элементов справа от i-го элемента\n      rightSum += arr[j];\n    }\n\n    if (leftSum === rightSum) { // если суммы равны, запоминаем индекс и выходим из цикла\n      index = i;\n      broke;\n    }\n  }\n\n  if (indexOf === -1) { // если индекс не изменился, значит разделение невозможно\n    return []; // возвращаем пустой массив\n  }\n\n  // создаем результирующий массив\n  // в нем будет два подмассива: в первом подмассиве с индексом 0 будут элементы из левой части исходного массива,\n  // во втором подмассиве с индексом 1 - элементы из правой части исходного массива\n  const result = [[], []];\n\n  for (let i = 0; i < arr.length; i++) { // заполняем результирующий массив\n    if (i <= index) { // если индекс меньше или равен индексу разделения, то элементы попадают в левую часть\n      rsult[0].push(arr[i]);\n    } els { // иначе в правую\n      result[1].push(arr[i]);\n    }\n  }\n  return res;\n}",
  "completedSolution": "function splitByEqualSum(arr) {\n  let leftSum = 0; // сумма элементов левой части массива\n  let rightSum = 0; // сумма элементов правой части массива\n  let index = -1; // индекс элемента, по которому будет происходить разделение массива\n\n  for (let i = 0; i < arr.length - 1; i++) {\n    leftSum += arr[i]; // сумма элементов слева от i-го элемента, включая его\n    rightSum = 0;   // обнуление суммы элементов справа от i-го элемента\n    for (let j = i + 1; j < arr.length; j++) { // вычисляем сумму элементов справа от i-го элемента\n      rightSum += arr[j];\n    }\n\n    if (leftSum === rightSum) { // если суммы равны, запоминаем индекс и выходим из цикла\n      index = i;\n      break;\n    }\n  }\n\n  if (index === -1) { // если индекс не изменился, значит разделение невозможно\n    return []; // возвращаем пустой массив\n  }\n\n  // создаем результирующий массив\n  // в нем будет два подмассива: в первом подмассиве с индексом 0 будут элементы из левой части исходного массива,\n  // во втором подмассиве с индексом 1 - элементы из правой части исходного массива\n  const result = [[], []];\n\n  for (let i = 0; i < arr.length; i++) { // заполняем результирующий массив\n    if (i <= index) { // если индекс меньше или равен индексу разделения, то элементы попадают в левую часть\n      result[0].push(arr[i]);\n    } else { // иначе в правую\n      result[1].push(arr[i]);\n    }\n  }\n  return result;\n}",
  "openTest": "it('Created function splitByEqualSum', () => {\n  expect(splitByEqualSum).to.be.a('function');\n});\n\nit('splitByEqualSum([1, 2, 3, 4, 5, 5]) should return [[1, 2, 3, 4], [5, 5]]', () => {\n  expect(splitByEqualSum([1, 2, 3, 4, 5, 5])).to.deep.equal([[1, 2, 3, 4], [5, 5]]);\n});\n\nit('splitByEqualSum([-1, 2, 3, -4, 0]) should return [[-1, 2, 3, -4], [ 0]]', () => {\n  expect(splitByEqualSum([-1, 2, 3, -4, 0])).to.deep.equal([[-1, 2, 3, -4], [0]]);\n});\n\nit('splitByEqualSum([1, 2, 3, 4]) should return []', () => {\n  expect(splitByEqualSum([1, 2, 3, 4])).to.deep.equal([]);\n});\n\nit('splitByEqualSum([10, 2, 3, 4, 6, 5]) should return [[10, 2, 3], [4, 6, 5]]', () => {\n  expect(splitByEqualSum([10, 2, 3, 4, 6, 5])).to.deep.equal([[10, 2, 3], [4, 6, 5]]);\n});\n\nit('splitByEqualSum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1]) should return [[1, 2, 3, 4, 5, 6, 7], [8, 9, 10, 1]]', () => {\n  expect(splitByEqualSum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1])).to.deep.equal([[1, 2, 3, 4, 5, 6, 7], [8, 9, 10, 1]]);\n});\n\nit('splitByEqualSum([-11, 12, 3, 4]) should return [[-11, 12, 3], [4]]', () => {\n  expect(splitByEqualSum([-11, 12, 3, 4])).to.deep.equal([[-11, 12, 3], [4]]);\n});\n\nit('splitByEqualSum([1, 2, 3, 4, 5, -6, 8, -8, 9]) should return [[1, 2, 3, 4, 5, -6], [8, -8, 9]]', () => {\n  expect(splitByEqualSum([1, 2, 3, 4, 5, -6, 8, -8, 9])).to.deep.equal([[1, 2, 3, 4, 5, -6], [8, -8, 9]]);\n});\n\nit('splitByEqualSum([1, 2, 3, 4, 5, -6, 8, -8, 9, 10]) should return []', () => {\n  expect(splitByEqualSum([1, 2, 3, 4, 5, -6, 8, -8, 9, 10])).to.deep.equal([]);\n});\n\nit('splitByEqualSum([5, 2, 3]) should return [[5], [2, 3]]', () => {\n  expect(splitByEqualSum([5, 2, 3])).to.deep.equal([[5], [2, 3]]);\n});\n\nit('splitByEqualSum([5, 2, 3, 4]) should return [[5, 2], [3, 4]]', () => {\n  expect(splitByEqualSum([5, 2, 3, 4])).to.deep.equal([[5, 2], [3, 4]]);\n});\n\nit('splitByEqualSum([5]) should return []', () => {\n  expect(splitByEqualSum([5])).to.deep.equal([]);\n});\n\nit('splitByEqualSum([5, 5]) should return [[5], [5]]', () => {\n  expect(splitByEqualSum([5, 5])).to.deep.equal([[5], [5]]);\n});\n\nit('splitByEqualSum([5, -5]) should return []', () => {\n  expect(splitByEqualSum([5, -5])).to.deep.equal([]);\n});\n\nit('splitByEqualSum([5, 5, 5]) should return []', () => {\n  expect(splitByEqualSum([5, 5, 5])).to.deep.equal([]);\n});\n\nit('splitByEqualSum([5, 5, 5, 5]) should return [[5, 5], [5, 5]]', () => {\n  expect(splitByEqualSum([5, 5, 5, 5])).to.deep.equal([[5, 5], [5, 5]]);\n});\n\nit('splitByEqualSum([5, 5, -10]) should return []', () => {\n  expect(splitByEqualSum([5, 5, -10])).to.deep.equal([]);\n});\n\nit('splitByEqualSum([]) should return []', () => {\n  expect(splitByEqualSum([])).to.deep.equal([]);\n});",
  "hiddenTest": "",
  "programmingLang": "JavaScript",
  "status": "new",
  "level": "Easy",
  "showOpenTest": true,
  "active": false,
  "checker": "unit",
  "hint": {
    "en": "",
    "ru": ""
  }
}