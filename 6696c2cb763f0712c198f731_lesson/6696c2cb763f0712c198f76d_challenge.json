{
  "_id": "6696c2cb763f0712c198f76d",
  "name": {
    "en": "/*",
    "ru": "Найти последнюю строку-палиндром в массиве строк"
  },
  "instruction": {
    "en": "",
    "ru": "Напишите функцию `findLastPalindrome`, которая принимает массив строк.\n\nФункция должна идентифицировать последнюю строку в массиве, которая является палиндромом (читается одинаково в обоих направлениях, игнорируя регистр и пробелы).\n\nФункция возвращает объект с двумя свойствами: `newArr`, массив булевых значений, показывающих, является ли каждая их строк палиндромом, и `lastPalindrome`, содержащий последнюю строку-палиндром или сообщение о её отсутствии: `palindrome was not found`.\n\n\nПримеры запуска функции:\n```javascript\nconsole.log(findLastPalindrome([\"LEVel\", \"w o r l d\", \"r aDa r\", \"roCKet\", \"mA da  M \"]));\n// Вывод:\n// {\n//   newArr: [true, false, true, false, true],\n//   lastPalindrome: 'mA da  M '\n// }\n\nconsole.log(findLastPalindrome([\"hello\", \"world\", \"python\", \"RaceCar\"]));\n// Вывод:\n// {\n//   newArr: [false, false, false, true],\n//   lastPalindrome: 'RaceCar'\n// }\n\nconsole.log(findLastPalindrome([\"java\", \"javascript\", \"ruby\"]));\n// Вывод:\n// {\n//   newArr: [false, false, false],\n//   lastPalindrome: 'palindrome was not found'\n// }\n```"
  },
  "initialSolution": "function findLastPalindrome(){\n\n}",
  "completedSolution": "function findLastPalindrome(words) {\n  const isPalindrome = str => {\n    let original = ''\n    let reversed = ''\n    for(let el of str){\n      if(el !== ' '){\n        original += el.toLowerCase()\n        reversed = el.toLowerCase() + reversed\n      }\n    }\n    return original === reversed\n  }\n\n  const newArr = words.map(el => isPalindrome(el))\n  const lastPalindrome = words.findLast((_, i) => newArr[i])\n\n  return {newArr, lastPalindrome: lastPalindrome ? lastPalindrome : 'palindrome was not found'};\n}",
  "openTest": "it('Created function findLastPalindrome', () => {\n  expect(findLastPalindrome).to.be.a('function');\n});\n\nit('findLastPalindrome([\"LEVel\", \"w o r l d\", \"r aDa r\", \"roCKet\", \"mA da  M \"]) should return {newArr: [true, false, true, false, true], lastPalindrome: \"mA da  M \"}', function() {\n  expect(findLastPalindrome([\"LEVel\", \"w o r l d\", \"r aDa r\", \"roCKet\", \"mA da  M \"])).to.deep.equal({\n    newArr: [true, false, true, false, true],\n    lastPalindrome: \"mA da  M \"\n  });\n});\n\nit('findLastPalindrome([\"hello\", \"world\", \"python\", \"RaceCar\"]) should return {newArr: [false, false, false, true], lastPalindrome: \"RaceCar\"}', function() {\n  expect(findLastPalindrome([\"hello\", \"world\", \"python\", \"RaceCar\"])).to.deep.equal({\n    newArr: [false, false, false, true],\n    lastPalindrome: \"RaceCar\"\n  });\n});\n\nit('findLastPalindrome([\"java\", \"javascript\", \"ruby\"]) should return {newArr: [false, false, false], lastPalindrome: \"palindrome was not found\"}', function() {\n  expect(findLastPalindrome([\"java\", \"javascript\", \"ruby\"])).to.deep.equal({\n    newArr: [false, false, false],\n    lastPalindrome: \"palindrome was not found\"\n  });\n});\n\nit('findLastPalindrome([\"Madam\", \"Nurse\", \"Run\", \"Able was I saw Elba\"]) should return {newArr: [true, false, false, true], lastPalindrome: \"Able was I saw Elba\"}', function() {\n  expect(findLastPalindrome([\"Madam\", \"Nurse\", \"Run\", \"Able was I saw Elba\"])).to.deep.equal({\n    newArr: [true, false, false, true],\n    lastPalindrome: \"Able was I saw Elba\"\n  });\n});\n\nit('findLastPalindrome([\"step on no pets\", \"evacuate\", \"level\", \"lager\", \"regal\"]) should return {newArr: [true, false, true, false, false], lastPalindrome: \"level\"}', function() {\n  expect(findLastPalindrome([\"step on no pets\", \"evacuate\", \"level\", \"lager\", \"regal\"])).to.deep.equal({\n    newArr: [true, false, true, false, false],\n    lastPalindrome: \"level\"\n  });\n});\n\nit('findLastPalindrome([\"not a palindrome\", \"neither is this\", \"nor this\"]) should return {newArr: [false, false, false], lastPalindrome: \"palindrome was not found\"}', function() {\n  expect(findLastPalindrome([\"not a palindrome\", \"neither is this\", \"nor this\"])).to.deep.equal({\n    newArr: [false, false, false],\n    lastPalindrome: \"palindrome was not found\"\n  });\n});\n\nit('findLastPalindrome([\"No lemon, no melon\", \"Was it a car or a cat I saw\", \"Murder for a jar of red rum\"]) should return {newArr: [true, true, true], lastPalindrome: \"Murder for a jar of red rum\"}', function() {\n  expect(findLastPalindrome([\"No lemon, no melon\", \"Was it a car or a cat I saw\", \"Murder for a jar of red rum\"])).to.deep.equal({\n    newArr: [true, true, true],\n    lastPalindrome: \"Murder for a jar of red rum\"\n  });\n});\n\nit('findLastPalindrome([\"racecar\", \"kayak\", \"civic\", \"deified\", \"rotator\"]) should return {newArr: [true, true, true, true, true], lastPalindrome: \"rotator\"}', function() {\n  expect(findLastPalindrome([\"racecar\", \"kayak\", \"civic\", \"deified\", \"rotator\"])).to.deep.equal({\n    newArr: [true, true, true, true, true],\n    lastPalindrome: \"rotator\"\n  });\n});\n\nit('findLastPalindrome([\"A Santa Lived As a Devil At NASA\", \"Live on time, emit no evil\", \"Step on no pets\"]) should return {newArr: [true, true, true], lastPalindrome: \"Step on no pets\"}', function() {\n  expect(findLastPalindrome([\"A Santa Lived As a Devil At NASA\", \"Live on time, emit no evil\", \"Step on no pets\"])).to.deep.equal({\n    newArr: [true, true, true],\n    lastPalindrome: \"Step on no pets\"\n  });\n});",
  "hiddenTest": "",
  "programmingLang": "JavaScript",
  "status": "new",
  "level": "Easy",
  "showOpenTest": true,
  "active": false,
  "checker": "unit",
  "hint": {
    "en": "",
    "ru": ""
  }
}