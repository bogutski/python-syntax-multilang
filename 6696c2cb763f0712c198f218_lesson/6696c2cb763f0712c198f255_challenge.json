{
  "_id": "6696c2cb763f0712c198f255",
  "name": {
    "en": "/*",
    "ru": "Найти симметричную разность двух массивов"
  },
  "instruction": {
    "en": "",
    "ru": "Создайте функцию `calculateSymmetricDifference`, которая принимает два массива в качестве аргументов.\n\nФункция должна возвращать массив, содержащий симметричную разность двух массивов (элементы, присутствующие в одном из массивов, но не в обоих одновременно).\n\nРезультирующий массив не должен содержать дубликатов.\n\nЕсли оба массива пустые, либо все элементы совпадают, вернуть пустой массив.\n\nПример запуска функции:\n```javascript\ncalculateSymmetricDifference([], [])  // []\ncalculateSymmetricDifference([1, 2], [2, 1])   // []\ncalculateSymmetricDifference([1, 2], [2, 3])   // [ 1, 3 ]\ncalculateSymmetricDifference([], [10, 20, 30]) // [ 10, 20, 30 ]\ncalculateSymmetricDifference(['a', 'b', 'c'], ['c', 'd', 'a']) // [ 'b', 'd' ]\n```"
  },
  "initialSolution": "fun",
  "completedSolution": "function calculateSymmetricDifference(arr1, arr2) {\n  const result = []\n\n  for(let i = 0; i < arr1.length; i++){\n    if(!arr2.includes(arr1[i]) && !result.includes(arr1[i])) result.push(arr1[i])\n  }\n\n  for(let i = 0; i < arr2.length; i++){\n    if(!arr1.includes(arr2[i]) && !result.includes(arr2[i])) result.push(arr2[i])\n  }\n\n  return result\n}",
  "openTest": "it('Function calculateSymmetricDifference is created', () => {\n  expect(calculateSymmetricDifference).to.be.a('function');\n});\n\nit('calculateSymmetricDifference([1, 2, 3], [2, 3, 4]) should return [1, 4]', () => {\n  expect(calculateSymmetricDifference([1, 2, 3], [2, 3, 4])).to.deep.equal([1, 4]);\n});\n\nit('calculateSymmetricDifference([\"apple\", \"banana\", \"cherry\"], [\"banana\", \"cherry\", \"fig\"]) should return [\"apple\", \"fig\"]', () => {\n  expect(calculateSymmetricDifference([\"apple\", \"banana\", \"cherry\"], [\"banana\", \"cherry\", \"fig\"])).to.deep.equal([\"apple\", \"fig\"]);\n});\n\nit('calculateSymmetricDifference([], [1, 2, 3]) should return [1, 2, 3]', () => {\n  expect(calculateSymmetricDifference([], [1, 2, 3])).to.deep.equal([1, 2, 3]);\n});\n\nit('calculateSymmetricDifference([true, false, null], [null, false, true]) should return []', () => {\n  expect(calculateSymmetricDifference([true, false, null], [null, false, true])).to.deep.equal([]);\n});\n\nit('calculateSymmetricDifference([\"1\", \"2\", \"3\"], [1, 2, 3]) should return [\"1\", \"2\", \"3\", 1, 2, 3]', () => {\n  expect(calculateSymmetricDifference([\"1\", \"2\", \"3\"], [1, 2, 3])).to.deep.equal([\"1\", \"2\", \"3\", 1, 2, 3]);\n});\n\nit('calculateSymmetricDifference with identical numeric arrays should return []', () => {\n  expect(calculateSymmetricDifference([1, 2, 3], [1, 2, 3])).to.deep.equal([]);\n});\n\nit('calculateSymmetricDifference with both arrays being empty should return []', () => {\n  expect(calculateSymmetricDifference([], [])).to.deep.equal([]);\n});\n\nit('calculateSymmetricDifference with arrays containing mixed types should return the correct symmetric difference', () => {\n  expect(calculateSymmetricDifference([\"1\", 2, true], [1, \"2\", false])).to.deep.equal([\"1\", 2, true, 1, \"2\", false]);\n});\n\nit('calculateSymmetricDifference with one array containing all elements of the other should return the non-common elements', () => {\n  expect(calculateSymmetricDifference([1, 2, 3, 4], [2, 3])).to.deep.equal([1, 4]);\n});\n\nit('calculateSymmetricDifference with arrays containing duplicate values should return a result without duplicates', () => {\n  expect(calculateSymmetricDifference([1, 2, 2, 3], [3, 4, 4, 5])).to.deep.equal([1, 2, 4, 5]);\n});\n\nit('calculateSymmetricDifference with non-primitive elements (objects) being compared by reference should consider them distinct', () => {\n  const obj1 = { key: 'value1' };\n  const obj2 = { key: 'value2' };\n  const obj3 = { key: 'value1' };\n  expect(calculateSymmetricDifference([obj1, obj2], [obj2, obj3])).to.deep.equal([obj1, obj3]);\n});\n\nit('calculateSymmetricDifference with arrays containing complex types (arrays, objects) should handle them correctly 1', () => {\n  expect(calculateSymmetricDifference([[\"apple\"], { key: \"value\" }], [[\"banana\"], { key: \"value\" }])).to.deep.equal([[\"apple\"], { key: \"value\" }, [\"banana\"], { key: \"value\" }]);\n});\n\nit('calculateSymmetricDifference with arrays containing complex types (arrays, objects) should handle them correctly 2', () => {\n  const obj = { key: \"value\" }\n  const arr = [\"apple\"]\n  expect(calculateSymmetricDifference([obj, arr], [obj, arr])).to.deep.equal([]);\n});\n\nit('calculateSymmetricDifference with arrays containing undefined and null values should treat them as valid elements', () => {\n  expect(calculateSymmetricDifference([undefined, null], [null, undefined, \"test\"])).to.deep.equal([\"test\"]);\n});\n\nit('calculateSymmetricDifference with arrays containing boolean values only should correctly identify symmetric difference', () => {\n  expect(calculateSymmetricDifference([true, false], [true, true, false, false])).to.deep.equal([]);\n});",
  "hiddenTest": "",
  "programmingLang": "JavaScript",
  "status": "new",
  "level": "Easy",
  "showOpenTest": true,
  "active": false,
  "checker": "unit",
  "hint": {
    "en": "",
    "ru": ""
  }
}