Преобразование строки в массив - важная часть изучения Java Script

**Метод `split()`** 

Его можно применять ТОЛЬКО над строкой!

Синтаксис:

`split(separator)`

В скобках указывается разделитель внутри строки. Необязательный параметр.

Давайте рассмотрим на примере метод преобразованиия строки в массив с
помощью встроенного метода строк `split()`.
```javascript
const str = 'Hello JS';
const arr = str.split('') //разделитель - пустая строка
console.log(arr)

["H", "e", "l", "l", "o", " ", "J", "S"]
```
В данном случае разделитель задан в виде пустой строки и 
 строка str преобразована в массив символов.

Рассмотрим другие примеры разделителя:
```javascript
const str = 'Hello JS';
const arr = str.split(' ') //разделитель - строка с пробелом внутри
console.log(arr)

["Hello", "JS"]
```
Строка преобразована в массив с двумя элементами, разделенных по элементу пробел.
```javascript
const str = 'Hello JS !!! .. ++';
const arr = str.split(' ') //разделитель - строка с пробелом внутри
console.log(arr)

["Hello", "JS", "!!!", "..", "++"]
```
Все элементы разделенные пробелом собираются в элемент массива.
```javascript
const str = 'Hello JS';
const arr = str.split(',') //разделитель - строка с запятой внутри
console.log(arr)
  
["Hello JS"]
```
Строка преобразована в массив только с одним элементом, так как запятая не встречается
в строке.

Попробуйте попрактиковаться, записывая разные варианты разделителя
с разными строками и посмотрите какой будет результат.

С помощью метода split() можно преобразовать строку с любым количеством символом в массив.

Иногда необходимо преобразовывать строку в массив без использования методов.

Тогда можно воспользоваться **циклом `for`**

```javascript
const str = 'Hello JS-Coding PlayGround';
const arr = []; 
for (let i = 0; i < str.length; i++){
  let acc = ''; //создаем аккумулятор в виде пустой строки, чтобы собирать слова
// чтобы собрать целое слово, необходимо применить условие if  
  if (str[i] !== ' ') acc +=str[i] //если элемент не равен пробелу, то добавляем его в аккумулятор
  else {                           // действие когда мы встретились с пробелом
    arr.push(acc);                 // мы добавляем в массив всё, что мы собрали в аккумуляторе
    acc = '';                      // и очищаем аккумулятор, делая его обратно пустой строкой
  }
}

console.log(arr)
  
["", ""]
```
В данном случае мы получили массив с пустыми строками.
Это произошло по причине того, что аккумулятор был создан внутри цикла и 
на каждой итерации `acc` очищался вновь до пустой строки.

Чтобы такого не происходимо аккумулятор `acc` необходимо создавать до запуска цикла.
```javascript
const str = 'Hello JS-Coding PlayGround';
const arr = [];
let acc = '';
for (let i = 0; i < str.length; i++){
  if (str[i] !== ' ') acc +=str[i] 
  else {                           
    arr.push(acc);                 
    acc = '';                      
  }
}

console.log(arr)
  
["Hello", "JS-Coding"]
```
Массив заполняется, но последнее слово не приходит в массив.
Это связано с тем, что после последнего слова в строке у нас нет пробела и
условие `else` никогда не выполняется. То есть не происходит команды `push`.

```javascript
const str = 'Hello JS-Coding PlayGround';
const arr = [];
let acc = '';
for (let i = 0; i < str.length; i++){
  if (str[i] !== ' ') acc +=str[i] 
  else {                           
    arr.push(acc);                 
    acc = '';                      
  }
}
arr.push(acc)     //после отработки цикла добавляем последний push аккумулятора
console.log(arr)

["Hello", "JS-Coding", "PlayGround"]
```

Или можно проверить, что аккумулятор накопил последний элемент массива.

Добавим условие, что элемент цикла равен последнему символу строки:
```javascript
const str = 'H el lo';
const arr = [];
let acc = '';
for (let i = 0; i < str.length; i++){
  if (str[i] !== ' ') acc +=str[i] 
  else {                           
    arr.push(acc);                 
    acc = '';                      
  }
  if(i === str.length-1) arr.push(acc)
}
console.log(arr)

["H", "el", "lo"] //цикл работает правильно
```

Попробуйте оптимизировать код, чтобы он был не таким длинным.
